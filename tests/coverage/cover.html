
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/vindosVP/go-pass/cmd/client/main.go (0.0%)</option>
				
				<option value="file1">github.com/vindosVP/go-pass/cmd/migrator/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/vindosVP/go-pass/cmd/migrator/main.go (0.0%)</option>
				
				<option value="file3">github.com/vindosVP/go-pass/cmd/server/config/config.go (0.0%)</option>
				
				<option value="file4">github.com/vindosVP/go-pass/cmd/server/main.go (0.0%)</option>
				
				<option value="file5">github.com/vindosVP/go-pass/internal/app/app.go (0.0%)</option>
				
				<option value="file6">github.com/vindosVP/go-pass/internal/app/grpc/app.go (0.0%)</option>
				
				<option value="file7">github.com/vindosVP/go-pass/internal/grpc/auth/auth.go (97.6%)</option>
				
				<option value="file8">github.com/vindosVP/go-pass/internal/grpc/auth/mocks/Auth.go (76.5%)</option>
				
				<option value="file9">github.com/vindosVP/go-pass/internal/jwt/jwt.go (77.3%)</option>
				
				<option value="file10">github.com/vindosVP/go-pass/internal/proto/auth/auth.pb.go (8.1%)</option>
				
				<option value="file11">github.com/vindosVP/go-pass/internal/proto/auth/auth_grpc.pb.go (0.0%)</option>
				
				<option value="file12">github.com/vindosVP/go-pass/internal/services/auth/auth.go (82.9%)</option>
				
				<option value="file13">github.com/vindosVP/go-pass/internal/services/auth/mocks/UserStorage.go (77.1%)</option>
				
				<option value="file14">github.com/vindosVP/go-pass/internal/storage/postgres/postgres.go (81.5%)</option>
				
				<option value="file15">github.com/vindosVP/go-pass/pkg/db/db.go (100.0%)</option>
				
				<option value="file16">github.com/vindosVP/go-pass/pkg/logger/handlers/slogdiscard/slogdiscard.go (60.0%)</option>
				
				<option value="file17">github.com/vindosVP/go-pass/pkg/logger/handlers/slogpretty/slogpretty.go (0.0%)</option>
				
				<option value="file18">github.com/vindosVP/go-pass/pkg/logger/sl/sl.go (50.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

func main() {<span class="cov0" title="0">
        // client realisation
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package migratorConfig configures the migrator
package migratorConfig

import (
        "flag"
        "fmt"
        "os"

        "github.com/go-playground/validator/v10"
        "github.com/spf13/viper"
)

// MigratorConfig consists of fields for migrator configuration
type MigratorConfig struct {
        DB             DBConfig `yaml:"db"`
        MigrationsPath string   `yaml:"migrationsPath" validate:"required"`
}

// DBConfig consists of fields for database configuration
type DBConfig struct {
        Host     string `yaml:"host" validate:"required"`
        Port     int    `yaml:"port" validate:"required"`
        User     string `yaml:"user" validate:"required"`
        Password string `yaml:"password" validate:"required"`
        Database string `yaml:"database" validate:"required"`
}

// MustLoad loads the MigratorConfig from file
func MustLoad() *MigratorConfig <span class="cov0" title="0">{
        path := configPath()
        if path == "" </span><span class="cov0" title="0">{
                panic("config path is empty")</span>
        }

        <span class="cov0" title="0">viper.SetConfigFile(path)
        conf := &amp;MigratorConfig{}

        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to parse config: %w", err))</span>
        }

        <span class="cov0" title="0">fmt.Println(viper.Get("migrations_path"))

        err = viper.Unmarshal(conf)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to unmarshal config: %w", err))</span>
        }

        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(conf); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("missing requiered attributes: %w", err))</span>
        }

        <span class="cov0" title="0">return conf</span>
}

func configPath() string <span class="cov0" title="0">{
        var res string

        flag.StringVar(&amp;res, "c", "", "path to config file")
        flag.Parse()

        if res == "" </span><span class="cov0" title="0">{
                res = os.Getenv("CONFIG_PATH")
        }</span>

        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "errors"
        "fmt"

        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        _ "github.com/golang-migrate/migrate/v4/source/github"
        _ "github.com/mattes/migrate/source/file"

        migratorConfig "github.com/vindosVP/go-pass/cmd/migrator/config"
        "github.com/vindosVP/go-pass/pkg/db"
)

func main() <span class="cov0" title="0">{

        conf := migratorConfig.MustLoad()
        m, err := migrate.New(
                fmt.Sprintf("file://%s", conf.MigrationsPath),
                db.PostgresDSN(conf.DB.Host, conf.DB.Port, conf.DB.User, conf.DB.Password, conf.DB.Database))

        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to connect database: %w", err))</span>
        }

        <span class="cov0" title="0">if err := m.Up(); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                        fmt.Println("no migrations to apply")
                        return
                }</span>
                <span class="cov0" title="0">panic(fmt.Errorf("failed to apply migrations: %w", err))</span>
        }

        <span class="cov0" title="0">fmt.Println("migrations applied")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package serverConfig configures the server
package serverConfig

import (
        "encoding/json"
        "flag"
        "fmt"
        "os"
        "time"

        "github.com/go-playground/validator/v10"
        "github.com/spf13/viper"

        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

// ServerConfig consists of fields for server configuration
type ServerConfig struct {
        Env  string     `yaml:"env" validate:"required"`
        DB   DBConfig   `yaml:"db"`
        GRPC GRPCConfig `yaml:"grpc"`
        Auth AuthConfig `yaml:"auth"`
}

// String turns the ServerConfig to string
func (s *ServerConfig) String() string <span class="cov0" title="0">{
        out, err := json.Marshal(s)

        if err != nil </span><span class="cov0" title="0">{
                sl.Err(fmt.Errorf("failed to marshal server config: %w", err))
        }</span>

        <span class="cov0" title="0">return string(out)</span>
}

// DBConfig consists of fields for database configuration
type DBConfig struct {
        Host     string `yaml:"host" validate:"required"`
        Port     int    `yaml:"port" validate:"required"`
        User     string `yaml:"user" validate:"required"`
        Password string `yaml:"password" validate:"required"`
        Database string `yaml:"database" validate:"required"`
}

// GRPCConfig consists of fields for grpc configuration
type GRPCConfig struct {
        Port    int           `yaml:"port" validate:"required"`
        Timeout time.Duration `yaml:"timeout" validate:"required"`
}

// AuthConfig consists of fields for authentication configuration
type AuthConfig struct {
        Secret   string        `yaml:"secret" validate:"required"`
        TokenTTL time.Duration `yaml:"tokenTTL" validate:"required"`
}

// MustLoad loads the ServerConfig from file
func MustLoad() *ServerConfig <span class="cov0" title="0">{
        path := configPath()
        if path == "" </span><span class="cov0" title="0">{
                panic("config path is empty")</span>
        }

        <span class="cov0" title="0">viper.SetConfigFile(path)
        conf := &amp;ServerConfig{}

        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to parse config: %w", err))</span>
        }

        <span class="cov0" title="0">err = viper.Unmarshal(conf)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to unmarshal config: %w", err))</span>
        }

        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(conf); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("missing requiered attributes: %w", err))</span>
        }

        <span class="cov0" title="0">return conf</span>
}

func configPath() string <span class="cov0" title="0">{
        var res string

        flag.StringVar(&amp;res, "c", "", "path to config file")
        flag.Parse()

        if res == "" </span><span class="cov0" title="0">{
                res = os.Getenv("CONFIG_PATH")
        }</span>

        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "log/slog"
        "os"
        "os/signal"
        "syscall"

        "github.com/jackc/pgx/v5/pgxpool"

        serverConfig "github.com/vindosVP/go-pass/cmd/server/config"
        "github.com/vindosVP/go-pass/internal/app"
        "github.com/vindosVP/go-pass/pkg/db"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

var (
        buildVersion = "N/A"
        buildDate    = "N/A"
        buildCommit  = "N/A"
)

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        printBuildInfo()
        conf := serverConfig.MustLoad()
        sl.SetupLogger(conf.Env)

        sl.Log.Info("Starting server...", slog.String("config", conf.String()))

        dsn := db.PostgresDSN(conf.DB.Host, conf.DB.Port, conf.DB.User, conf.DB.Password, conf.DB.Database)
        pool, err := pgxpool.New(ctx, dsn)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(fmt.Errorf("error connecting to database: %w", err))
        }</span>
        <span class="cov0" title="0">a := app.New(conf.GRPC.Port, pool, conf.Auth.TokenTTL, conf.Auth.Secret)

        go func() </span><span class="cov0" title="0">{
                a.MustRun()
        }</span>()

        <span class="cov0" title="0">stop := make(chan os.Signal, 3)
        signal.Notify(stop, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT)

        &lt;-stop

        a.Stop()
        sl.Log.Info("Gracefully stopped")</span>
}

func printBuildInfo() <span class="cov0" title="0">{
        fmt.Printf("Build version: %s\n", buildVersion)
        fmt.Printf("Build date: %s\n", buildDate)
        fmt.Printf("Build commit: %s\n", buildCommit)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package app creates and works with the App
package app

import (
        "time"

        "github.com/jackc/pgx/v5/pgxpool"

        grpcapp "github.com/vindosVP/go-pass/internal/app/grpc"
        "github.com/vindosVP/go-pass/internal/services/auth"
        "github.com/vindosVP/go-pass/internal/storage/postgres"
)

// App consist the grpc server
type App struct {
        grpcServer *grpcapp.App
}

// MustRun runs the app
func (a *App) MustRun() <span class="cov0" title="0">{
        a.grpcServer.MustRun()
}</span>

// Stop stops app
func (a *App) Stop() <span class="cov0" title="0">{
        a.grpcServer.Stop()
}</span>

// New creates the App instance
func New(port int, pool *pgxpool.Pool, tokenTTL time.Duration, secret string) *App <span class="cov0" title="0">{
        s := postgres.New(pool)
        a := auth.New(s, tokenTTL, secret)
        grpcApp := grpcapp.New(port, a)
        return &amp;App{
                grpcServer: grpcApp,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package grpcapp

import (
        "context"
        "fmt"
        "log/slog"
        "net"

        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/recovery"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        authgrpc "github.com/vindosVP/go-pass/internal/grpc/auth"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

// App is a grpc app representation.
type App struct {
        grpcServer *grpc.Server
        port       int
}

// MustRun runs gRPC server and panics if any error occurs.
func (a *App) MustRun() <span class="cov0" title="0">{
        if err := a.Run(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// Run runs gRPC server.
func (a *App) Run() error <span class="cov0" title="0">{
        l, err := net.Listen("tcp", fmt.Sprintf(":%d", a.port))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen: %w", err)
        }</span>
        <span class="cov0" title="0">sl.Log.Info("grpc server started", slog.String("addr", l.Addr().String()))
        if err := a.grpcServer.Serve(l); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Stop stops gRPC server.
func (a *App) Stop() <span class="cov0" title="0">{
        sl.Log.Info("stopping gRPC server", slog.Int("port", a.port))
        a.grpcServer.GracefulStop()
}</span>

// New creates a grpc app instance.
func New(port int, auth authgrpc.Auth) *App <span class="cov0" title="0">{
        loggingOpts := []logging.Option{
                logging.WithLogOnEvents(
                        logging.PayloadReceived, logging.PayloadSent,
                ),
        }
        recoveryOpts := []recovery.Option{
                recovery.WithRecoveryHandler(func(p interface{}) (err error) </span><span class="cov0" title="0">{
                        sl.Log.Error("recovered from panic", slog.Any("panic", p))
                        return status.Errorf(codes.Internal, "internal error")
                }</span>),
        }
        <span class="cov0" title="0">grpcServer := grpc.NewServer(grpc.ChainUnaryInterceptor(
                recovery.UnaryServerInterceptor(recoveryOpts...),
                logging.UnaryServerInterceptor(InterceptorLogger(sl.Log), loggingOpts...),
        ))

        authgrpc.Register(grpcServer, auth)

        return &amp;App{
                grpcServer: grpcServer,
                port:       port,
        }</span>
}

// InterceptorLogger adapts slog logger to interceptor logger.
func InterceptorLogger(l *slog.Logger) logging.Logger <span class="cov0" title="0">{
        return logging.LoggerFunc(func(ctx context.Context, lvl logging.Level, msg string, fields ...any) </span><span class="cov0" title="0">{
                l.Log(ctx, slog.Level(lvl), msg, fields...)
        }</span>)
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package authgrpc consists the auth grpc server
package authgrpc

import (
        "context"
        "errors"
        "log/slog"
        "net/mail"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/vindosVP/go-pass/internal/models"
        authv1 "github.com/vindosVP/go-pass/internal/proto/auth"
        "github.com/vindosVP/go-pass/internal/services/auth"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

// Auth is an authentication API interface
//
//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=Auth
type Auth interface {
        CreateUser(ctx context.Context, email string, pass string) (*models.User, error)
        Login(ctx context.Context, email string, pass string) (string, error)
}

type server struct {
        authv1.UnimplementedAuthServer
        auth Auth
}

// Register registers the auth service.
func Register(gRPCServer *grpc.Server, auth Auth) <span class="cov0" title="0">{
        authv1.RegisterAuthServer(gRPCServer, &amp;server{auth: auth})
}</span>

// Login logs in the user
func (s *server) Login(ctx context.Context, in *authv1.LoginRequest) (*authv1.LoginResponse, error) <span class="cov8" title="1">{

        lg := sl.Log.With(slog.String("email", in.Email))
        lg.Info("handling login")

        err, code, msg := validate(in.Email, in.Password)
        if err != nil </span><span class="cov8" title="1">{
                lg.Info(msg)
                return nil, status.Error(code, msg)
        }</span>
        <span class="cov8" title="1">token, err := s.auth.Login(ctx, in.Email, in.Password)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, auth.ErrInvalidCredentials) </span><span class="cov8" title="1">{
                        lg.Info("invalid email or password")
                        return nil, status.Error(codes.Unauthenticated, "invalid email or password")
                }</span>
                <span class="cov8" title="1">lg.Error("failed to login", sl.Err(err))
                return nil, status.Error(codes.Internal, "failed to login")</span>
        }

        <span class="cov8" title="1">lg.Info("logged in")
        return &amp;authv1.LoginResponse{Token: token}, nil</span>
}

// Register registers a new user
func (s *server) Register(ctx context.Context, in *authv1.RegisterRequest) (*authv1.RegisterResponse, error) <span class="cov8" title="1">{

        lg := sl.Log.With(slog.String("email", in.Email))
        lg.Info("handling register")

        err, code, msg := validate(in.Email, in.Password)
        if err != nil </span><span class="cov8" title="1">{
                lg.Info(msg)
                return nil, status.Error(code, msg)
        }</span>
        <span class="cov8" title="1">user, err := s.auth.CreateUser(ctx, in.Email, in.Password)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, auth.ErrUserAlreadyExists) </span><span class="cov8" title="1">{
                        lg.Info("user with this email already exists")
                        return nil, status.Error(codes.InvalidArgument, "user with this email already exists")
                }</span>
                <span class="cov8" title="1">lg.Error("failed to create user", sl.Err(err))
                return nil, status.Error(codes.Internal, "failed to create user")</span>
        }

        <span class="cov8" title="1">lg.Info("registered user")
        return &amp;authv1.RegisterResponse{UserId: int64(user.ID)}, nil</span>
}

func validate(email string, password string) (error, codes.Code, string) <span class="cov8" title="1">{
        errValidation := errors.New("user validation error")
        if email == "" </span><span class="cov8" title="1">{
                return errValidation, codes.InvalidArgument, "email is requiered"
        }</span>
        <span class="cov8" title="1">if !isValidEmail(email) </span><span class="cov8" title="1">{
                return errValidation, codes.InvalidArgument, "email is invalid"
        }</span>
        <span class="cov8" title="1">if password == "" </span><span class="cov8" title="1">{
                return errValidation, codes.InvalidArgument, "password is required"
        }</span>
        <span class="cov8" title="1">return nil, codes.OK, ""</span>
}

func isValidEmail(email string) bool <span class="cov8" title="1">{
        _, err := mail.ParseAddress(email)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        models "github.com/vindosVP/go-pass/internal/models"
)

// Auth is an autogenerated mock type for the Auth type
type Auth struct {
        mock.Mock
}

// CreateUser provides a mock function with given fields: ctx, email, pass
func (_m *Auth) CreateUser(ctx context.Context, email string, pass string) (*models.User, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, email, pass)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateUser")</span>
        }

        <span class="cov8" title="1">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email, pass)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, pass)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, pass)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// Login provides a mock function with given fields: ctx, email, pass
func (_m *Auth) Login(ctx context.Context, email string, pass string) (string, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, email, pass)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Login")</span>
        }

        <span class="cov8" title="1">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email, pass)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, pass)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, pass)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewAuth creates a new instance of Auth. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAuth(t interface {
        mock.TestingT
        Cleanup(func())
}) *Auth <span class="cov8" title="1">{
        mock := &amp;Auth{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package jwt works with jwt-tokens
package jwt

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"

        "github.com/vindosVP/go-pass/internal/models"
)

// NewToken creates new JWT token for given user.
func NewToken(user *models.User, duration time.Duration, secret string) (string, error) <span class="cov8" title="1">{
        token := jwt.New(jwt.SigningMethodHS256)

        claims := token.Claims.(jwt.MapClaims)
        claims["uid"] = user.ID
        claims["email"] = user.Email
        claims["exp"] = time.Now().Add(duration).Unix()

        tokenString, err := token.SignedString([]byte(secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}

// VerifyToken verifies users token.
func VerifyToken(tokenString string, secret string) (string, error) <span class="cov8" title="1">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return []byte(secret), nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid token: %w", err)
        }</span>
        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid token: %w", err)
        }</span>
        <span class="cov8" title="1">email, ok := claims["email"].(string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to extract email from token")
        }</span>
        <span class="cov8" title="1">return email, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        v4.25.0
// source: auth.proto

package authv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// RegisterRequest is a register handler request
type RegisterRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email    string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`       // Email of the user to register.
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"` // Password of the user to register.
}

func (x *RegisterRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RegisterRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{0}
}</span>

func (x *RegisterRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// RegisterRequest is a register handler request
type RegisterResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"` // User ID of the registered user.
}

func (x *RegisterResponse) Reset() <span class="cov0" title="0">{
        *x = RegisterResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RegisterResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterResponse.ProtoReflect.Descriptor instead.
func (*RegisterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{1}
}</span>

func (x *RegisterResponse) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// LoginRequest is a login handler request
type LoginRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email    string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`       // Email of the user to login.
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"` // Password of the user to login.
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{2}
}</span>

func (x *LoginRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// LoginResponse is a login handler response
type LoginResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"` // Auth token of the logged in user.
}

func (x *LoginResponse) Reset() <span class="cov0" title="0">{
        *x = LoginResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{3}
}</span>

func (x *LoginResponse) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_auth_proto protoreflect.FileDescriptor

var file_auth_proto_rawDesc = []byte{
        0x0a, 0x0a, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x04, 0x61, 0x75,
        0x74, 0x68, 0x22, 0x43, 0x0a, 0x0f, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70,
        0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70,
        0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x2b, 0x0a, 0x10, 0x52, 0x65, 0x67, 0x69, 0x73,
        0x74, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x17, 0x0a, 0x07, 0x75,
        0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x75, 0x73,
        0x65, 0x72, 0x49, 0x64, 0x22, 0x40, 0x0a, 0x0c, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61,
        0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61,
        0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x25, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x32, 0x73, 0x0a,
        0x04, 0x41, 0x75, 0x74, 0x68, 0x12, 0x39, 0x0a, 0x08, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
        0x72, 0x12, 0x15, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
        0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e,
        0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x30, 0x0a, 0x05, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x12, 0x2e, 0x61, 0x75, 0x74, 0x68,
        0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e,
        0x61, 0x75, 0x74, 0x68, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x42, 0x27, 0x5a, 0x25, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
        0x2f, 0x76, 0x69, 0x6e, 0x64, 0x6f, 0x73, 0x56, 0x50, 0x2f, 0x67, 0x6f, 0x2d, 0x70, 0x61, 0x73,
        0x73, 0x2f, 0x76, 0x31, 0x3b, 0x61, 0x75, 0x74, 0x68, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x33,
}

var (
        file_auth_proto_rawDescOnce sync.Once
        file_auth_proto_rawDescData = file_auth_proto_rawDesc
)

func file_auth_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_auth_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_auth_proto_rawDescData = protoimpl.X.CompressGZIP(file_auth_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_auth_proto_rawDescData</span>
}

var file_auth_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_auth_proto_goTypes = []interface{}{
        (*RegisterRequest)(nil),  // 0: auth.RegisterRequest
        (*RegisterResponse)(nil), // 1: auth.RegisterResponse
        (*LoginRequest)(nil),     // 2: auth.LoginRequest
        (*LoginResponse)(nil),    // 3: auth.LoginResponse
}
var file_auth_proto_depIdxs = []int32{
        0, // 0: auth.Auth.Register:input_type -&gt; auth.RegisterRequest
        2, // 1: auth.Auth.Login:input_type -&gt; auth.LoginRequest
        1, // 2: auth.Auth.Register:output_type -&gt; auth.RegisterResponse
        3, // 3: auth.Auth.Login:output_type -&gt; auth.LoginResponse
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_auth_proto_init() }</span>
func file_auth_proto_init() <span class="cov8" title="1">{
        if File_auth_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_auth_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RegisterRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RegisterResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoginRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoginResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_auth_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_auth_proto_goTypes,
                DependencyIndexes: file_auth_proto_depIdxs,
                MessageInfos:      file_auth_proto_msgTypes,
        }.Build()
        File_auth_proto = out.File
        file_auth_proto_rawDesc = nil
        file_auth_proto_goTypes = nil
        file_auth_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v4.25.0
// source: auth.proto

package authv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
        Auth_Register_FullMethodName = "/auth.Auth/Register"
        Auth_Login_FullMethodName    = "/auth.Auth/Login"
)

// AuthClient is the client API for Auth service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthClient interface {
        // Register registers a new user.
        Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
        // Login logs in a user and returns an auth token.
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
}

type authClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthClient(cc grpc.ClientConnInterface) AuthClient <span class="cov0" title="0">{
        return &amp;authClient{cc}
}</span>

func (c *authClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RegisterResponse)
        err := c.cc.Invoke(ctx, Auth_Register_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LoginResponse)
        err := c.cc.Invoke(ctx, Auth_Login_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthServer is the server API for Auth service.
// All implementations must embed UnimplementedAuthServer
// for forward compatibility
type AuthServer interface {
        // Register registers a new user.
        Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
        // Login logs in a user and returns an auth token.
        Login(context.Context, *LoginRequest) (*LoginResponse, error)
        mustEmbedUnimplementedAuthServer()
}

// UnimplementedAuthServer must be embedded to have forward compatible implementations.
type UnimplementedAuthServer struct {
}

func (UnimplementedAuthServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}</span>
func (UnimplementedAuthServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedAuthServer) mustEmbedUnimplementedAuthServer() {<span class="cov0" title="0">}</span>

// UnsafeAuthServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServer will
// result in compilation errors.
type UnsafeAuthServer interface {
        mustEmbedUnimplementedAuthServer()
}

func RegisterAuthServer(s grpc.ServiceRegistrar, srv AuthServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;Auth_ServiceDesc, srv)
}</span>

func _Auth_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServer).Register(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Auth_Register_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServer).Register(ctx, req.(*RegisterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Auth_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Auth_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Auth_ServiceDesc is the grpc.ServiceDesc for Auth service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Auth_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "auth.Auth",
        HandlerType: (*AuthServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Register",
                        Handler:    _Auth_Register_Handler,
                },
                {
                        MethodName: "Login",
                        Handler:    _Auth_Login_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "auth.proto",
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package auth provides an API to create and log in users.
package auth

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "time"

        "golang.org/x/crypto/bcrypt"

        "github.com/vindosVP/go-pass/internal/jwt"
        "github.com/vindosVP/go-pass/internal/models"
        "github.com/vindosVP/go-pass/internal/storage"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

// UserStorage is a user storage interface.
//
//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=UserStorage
type UserStorage interface {
        CreateUser(ctx context.Context, email string, passHash []byte) (*models.User, error)
        UserByEmail(ctx context.Context, email string) (*models.User, error)
}

var (
        // ErrUserAlreadyExists - user already exists error.
        ErrUserAlreadyExists = errors.New("user already exists")

        // ErrInvalidCredentials - invalid credentials error.
        ErrInvalidCredentials = errors.New("invalid credentials")
)

// Auth consists the authentication fields.
type Auth struct {
        userStorage UserStorage
        tokenTTL    time.Duration
        secret      string
}

// New creates the Auth instance.
func New(us UserStorage, tokenTTL time.Duration, secret string) *Auth <span class="cov8" title="1">{
        return &amp;Auth{userStorage: us, tokenTTL: tokenTTL, secret: secret}
}</span>

// CreateUser creates a new user with provided email and password.
func (a *Auth) CreateUser(ctx context.Context, email string, pass string) (*models.User, error) <span class="cov8" title="1">{

        lg := sl.Log.With(slog.String("email", email))
        lg.Info("creating user")

        passHash, err := bcrypt.GenerateFromPassword([]byte(pass), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                lg.Error("failed to generate password hash", sl.Err(err))
                return nil, fmt.Errorf("failed to generate password hash: %w", err)
        }</span>
        <span class="cov8" title="1">user, err := a.userStorage.CreateUser(ctx, email, passHash)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, storage.ErrUserAlreadyExists) </span><span class="cov8" title="1">{
                        lg.Info("user already exists")
                        return nil, ErrUserAlreadyExists
                }</span>
                <span class="cov8" title="1">lg.Error("failed to create user", sl.Err(err))
                return nil, fmt.Errorf("failed to create user: %w", err)</span>
        }

        <span class="cov8" title="1">lg.Info("user created")
        return user, nil</span>
}

// Login logs in user with provided email and password.
func (a *Auth) Login(ctx context.Context, email string, pass string) (string, error) <span class="cov8" title="1">{

        lg := sl.Log.With(slog.String("email", email))
        lg.Info("logging in user")

        user, err := a.userStorage.UserByEmail(ctx, email)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, storage.ErrUserNotExist) </span><span class="cov8" title="1">{
                        lg.Info("invalid credentials")
                        return "", ErrInvalidCredentials
                }</span>
                <span class="cov0" title="0">lg.Error("failed to get user", sl.Err(err))
                return "", fmt.Errorf("failed to get user: %w", err)</span>
        }
        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword(user.PassHash, []byte(pass))
        if err != nil </span><span class="cov8" title="1">{
                lg.Info("invalid credentials")
                return "", ErrInvalidCredentials
        }</span>
        <span class="cov8" title="1">token, err := jwt.NewToken(user, a.tokenTTL, a.secret)
        if err != nil </span><span class="cov0" title="0">{
                lg.Error("failed to create token", sl.Err(err))
                return "", fmt.Errorf("failed to create token: %w", err)
        }</span>

        <span class="cov8" title="1">lg.Info("user logged in")
        return token, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        models "github.com/vindosVP/go-pass/internal/models"
)

// UserStorage is an autogenerated mock type for the UserStorage type
type UserStorage struct {
        mock.Mock
}

// CreateUser provides a mock function with given fields: ctx, email, passHash
func (_m *UserStorage) CreateUser(ctx context.Context, email string, passHash []byte) (*models.User, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, email, passHash)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateUser")</span>
        }

        <span class="cov8" title="1">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, []byte) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email, passHash)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, []byte) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, passHash)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, []byte) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, passHash)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UserByEmail provides a mock function with given fields: ctx, email
func (_m *UserStorage) UserByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, email)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UserByEmail")</span>
        }

        <span class="cov8" title="1">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewUserStorage creates a new instance of UserStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUserStorage(t interface {
        mock.TestingT
        Cleanup(func())
}) *UserStorage <span class="cov8" title="1">{
        mock := &amp;UserStorage{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package postgres is a package for postgres storage
package postgres

import (
        "context"
        "errors"
        "fmt"
        "syscall"
        "time"

        "github.com/avast/retry-go/v4"
        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"

        "github.com/vindosVP/go-pass/internal/models"
        "github.com/vindosVP/go-pass/internal/storage"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

var retryDelays = map[uint]time.Duration{
        0: 1 * time.Second,
        1: 3 * time.Second,
        2: 5 * time.Second,
}

// Storage consists the database
type Storage struct {
        db *pgxpool.Pool
}

// New creates the Storage instance
func New(db *pgxpool.Pool) *Storage <span class="cov8" title="1">{
        return &amp;Storage{db: db}
}</span>

// CreateUser creates user with provided email and password hash
func (s *Storage) CreateUser(ctx context.Context, email string, passHash []byte) (*models.User, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() (*models.User, error) </span><span class="cov8" title="1">{
                query := "insert into users (email, hashed_password, created_at) values ($1, $2, $3) returning id, email, hashed_password, created_at"
                row := s.db.QueryRow(ctx, query, email, passHash, time.Now())
                user := &amp;models.User{}
                if err := row.Scan(&amp;user.ID, &amp;user.Email, &amp;user.PassHash, &amp;user.CreatedAt); err != nil </span><span class="cov8" title="1">{
                        if pgErrCode(err) == pgerrcode.UniqueViolation </span><span class="cov8" title="1">{
                                return nil, storage.ErrUserAlreadyExists
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">return user, nil</span>
        }, retryOpts()...)
}

// UserByEmail finds a user by provided email
func (s *Storage) UserByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() (*models.User, error) </span><span class="cov8" title="1">{
                query := "select id, email, hashed_password, created_at from users where email = $1"
                row := s.db.QueryRow(ctx, query, email)
                user := &amp;models.User{}
                if err := row.Scan(&amp;user.ID, &amp;user.Email, &amp;user.PassHash, &amp;user.CreatedAt); err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                                return nil, storage.ErrUserNotExist
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">return user, nil</span>
        }, retryOpts()...)
}

func retryOpts() []retry.Option <span class="cov8" title="1">{
        return []retry.Option{
                retry.RetryIf(func(err error) bool </span><span class="cov8" title="1">{
                        return pgerrcode.IsConnectionException(pgErrCode(err)) || errors.Is(err, syscall.ECONNREFUSED)
                }</span>),
                retry.DelayType(func(n uint, err error, config *retry.Config) time.Duration <span class="cov0" title="0">{
                        delay := retryDelays[n]
                        return delay
                }</span>),
                retry.OnRetry(func(n uint, err error) <span class="cov0" title="0">{
                        sl.Log.Info(fmt.Sprintf("Failed to connect to database, retrying in %s", retryDelays[n]))
                }</span>),
                retry.Attempts(4),
                retry.LastErrorOnly(true),
        }
}

func pgErrCode(err error) string <span class="cov8" title="1">{
        if e, ok := err.(*pgconn.PgError); ok </span><span class="cov8" title="1">{
                return e.Code
        }</span>

        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package db consists the database utils
package db

import "fmt"

// PostgresDSN creates the postgres database dsn
func PostgresDSN(host string, port int, user string, password string, dbname string) string <span class="cov8" title="1">{
        return fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=disable", user, password, host, port, dbname)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package slogdiscard

import (
        "context"
        "log/slog"
)

type DiscardHandler struct{}

func NewDiscardHandler() *DiscardHandler <span class="cov8" title="1">{
        return &amp;DiscardHandler{}
}</span>

func (h *DiscardHandler) Handle(_ context.Context, _ slog.Record) error <span class="cov0" title="0">{
        return nil
}</span>

func (h *DiscardHandler) WithAttrs(_ []slog.Attr) slog.Handler <span class="cov8" title="1">{
        return h
}</span>

func (h *DiscardHandler) WithGroup(_ string) slog.Handler <span class="cov0" title="0">{
        return h
}</span>

func (h *DiscardHandler) Enabled(_ context.Context, _ slog.Level) bool <span class="cov8" title="1">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package slogpretty initializes and configures pretty logger
package slogpretty

import (
        "context"
        "encoding/json"
        "io"
        stdLog "log"
        "log/slog"

        "github.com/fatih/color"
)

// PrettyHandlerOptions consists logger options
type PrettyHandlerOptions struct {
        SlogOpts *slog.HandlerOptions
}

// PrettyHandler consists the handler fields
type PrettyHandler struct {
        opts PrettyHandlerOptions
        slog.Handler
        l     *stdLog.Logger
        attrs []slog.Attr
}

// NewPrettyHandler creates the pretty handler
func (opts PrettyHandlerOptions) NewPrettyHandler(
        out io.Writer,
) *PrettyHandler <span class="cov0" title="0">{
        h := &amp;PrettyHandler{
                Handler: slog.NewJSONHandler(out, opts.SlogOpts),
                l:       stdLog.New(out, "", 0),
        }

        return h
}</span>

// Handle creates the logger record
func (h *PrettyHandler) Handle(_ context.Context, r slog.Record) error <span class="cov0" title="0">{
        level := r.Level.String() + ":"

        switch r.Level </span>{
        case slog.LevelDebug:<span class="cov0" title="0">
                level = color.MagentaString(level)</span>
        case slog.LevelInfo:<span class="cov0" title="0">
                level = color.BlueString(level)</span>
        case slog.LevelWarn:<span class="cov0" title="0">
                level = color.YellowString(level)</span>
        case slog.LevelError:<span class="cov0" title="0">
                level = color.RedString(level)</span>
        }

        <span class="cov0" title="0">fields := make(map[string]interface{}, r.NumAttrs())

        r.Attrs(func(a slog.Attr) bool </span><span class="cov0" title="0">{
                fields[a.Key] = a.Value.Any()

                return true
        }</span>)

        <span class="cov0" title="0">for _, a := range h.attrs </span><span class="cov0" title="0">{
                fields[a.Key] = a.Value.Any()
        }</span>

        <span class="cov0" title="0">var b []byte
        var err error

        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                b, err = json.MarshalIndent(fields, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">timeStr := r.Time.Format("[15:05:05.000]")
        msg := color.CyanString(r.Message)

        h.l.Println(
                timeStr,
                level,
                msg,
                color.WhiteString(string(b)),
        )

        return nil</span>
}

// WithAttrs creates handler with attributes
func (h *PrettyHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return &amp;PrettyHandler{
                Handler: h.Handler,
                l:       h.l,
                attrs:   attrs,
        }
}</span>

// WithGroup creates handler with group
func (h *PrettyHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;PrettyHandler{
                Handler: h.Handler.WithGroup(name),
                l:       h.l,
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package sl initializes and configures slog logger
package sl

import (
        "log/slog"
        "os"

        "github.com/vindosVP/go-pass/pkg/logger/handlers/slogdiscard"
        "github.com/vindosVP/go-pass/pkg/logger/handlers/slogpretty"
)

const (
        // envLocal is a local environment
        envLocal = "local"

        // envLocal is a development environment
        envDev = "dev"

        // envLocal is a production environment
        envProd = "prod"

        // envTest is a test environment
        envTest = "test"
)

// Log consists configured logger instance
var Log *slog.Logger

// SetupLogger configures the logger depending on environment
func SetupLogger(env string) <span class="cov8" title="1">{
        var log *slog.Logger
        switch env </span>{
        case envLocal:<span class="cov0" title="0">
                opts := slogpretty.PrettyHandlerOptions{
                        SlogOpts: &amp;slog.HandlerOptions{
                                Level: slog.LevelDebug,
                        },
                }

                handler := opts.NewPrettyHandler(os.Stdout)

                log = slog.New(handler)</span>
        case envDev:<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelDebug}),
                )</span>
        case envProd:<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelInfo}),
                )</span>
        case envTest:<span class="cov8" title="1">
                log = slog.New(
                        slogdiscard.NewDiscardHandler(),
                )</span>
        }
        <span class="cov8" title="1">Log = log</span>
}

func Err(err error) slog.Attr <span class="cov8" title="1">{
        return slog.Attr{
                Key:   "error",
                Value: slog.StringValue(err.Error()),
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
