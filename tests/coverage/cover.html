
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/vindosVP/go-pass/cmd/client/main.go (0.0%)</option>
				
				<option value="file1">github.com/vindosVP/go-pass/cmd/migrator/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/vindosVP/go-pass/cmd/migrator/main.go (0.0%)</option>
				
				<option value="file3">github.com/vindosVP/go-pass/cmd/server/config/config.go (0.0%)</option>
				
				<option value="file4">github.com/vindosVP/go-pass/cmd/server/main.go (0.0%)</option>
				
				<option value="file5">github.com/vindosVP/go-pass/internal/app/app.go (0.0%)</option>
				
				<option value="file6">github.com/vindosVP/go-pass/internal/app/grpc/app.go (0.0%)</option>
				
				<option value="file7">github.com/vindosVP/go-pass/internal/filemanager/manager.go (10.0%)</option>
				
				<option value="file8">github.com/vindosVP/go-pass/internal/grpc/auth/auth.go (97.6%)</option>
				
				<option value="file9">github.com/vindosVP/go-pass/internal/grpc/auth/mocks/Auth.go (76.5%)</option>
				
				<option value="file10">github.com/vindosVP/go-pass/internal/grpc/passkeeper/mocks/Keeper.go (0.0%)</option>
				
				<option value="file11">github.com/vindosVP/go-pass/internal/grpc/passkeeper/passkeeper.go (0.0%)</option>
				
				<option value="file12">github.com/vindosVP/go-pass/internal/interceptors/auth.go (0.0%)</option>
				
				<option value="file13">github.com/vindosVP/go-pass/internal/jwt/jwt.go (76.0%)</option>
				
				<option value="file14">github.com/vindosVP/go-pass/internal/models/models.go (42.9%)</option>
				
				<option value="file15">github.com/vindosVP/go-pass/internal/proto/auth/auth.pb.go (8.1%)</option>
				
				<option value="file16">github.com/vindosVP/go-pass/internal/proto/auth/auth_grpc.pb.go (0.0%)</option>
				
				<option value="file17">github.com/vindosVP/go-pass/internal/proto/passkeeper/passkeeper.pb.go (2.5%)</option>
				
				<option value="file18">github.com/vindosVP/go-pass/internal/proto/passkeeper/passkeeper_grpc.pb.go (0.0%)</option>
				
				<option value="file19">github.com/vindosVP/go-pass/internal/services/auth/auth.go (82.9%)</option>
				
				<option value="file20">github.com/vindosVP/go-pass/internal/services/auth/mocks/UserStorage.go (77.1%)</option>
				
				<option value="file21">github.com/vindosVP/go-pass/internal/services/passkeeper/mocks/CardStorage.go (76.0%)</option>
				
				<option value="file22">github.com/vindosVP/go-pass/internal/services/passkeeper/mocks/FileStorage.go (50.8%)</option>
				
				<option value="file23">github.com/vindosVP/go-pass/internal/services/passkeeper/mocks/PasswordStorage.go (76.0%)</option>
				
				<option value="file24">github.com/vindosVP/go-pass/internal/services/passkeeper/mocks/TextStorage.go (76.0%)</option>
				
				<option value="file25">github.com/vindosVP/go-pass/internal/services/passkeeper/passkeeper.go (43.0%)</option>
				
				<option value="file26">github.com/vindosVP/go-pass/internal/storage/postgres/postgres.go (85.0%)</option>
				
				<option value="file27">github.com/vindosVP/go-pass/pkg/db/db.go (100.0%)</option>
				
				<option value="file28">github.com/vindosVP/go-pass/pkg/grpcmd/grpcmd.go (0.0%)</option>
				
				<option value="file29">github.com/vindosVP/go-pass/pkg/logger/handlers/slogdiscard/slogdiscard.go (60.0%)</option>
				
				<option value="file30">github.com/vindosVP/go-pass/pkg/logger/handlers/slogpretty/slogpretty.go (0.0%)</option>
				
				<option value="file31">github.com/vindosVP/go-pass/pkg/logger/sl/sl.go (50.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

func main() {<span class="cov0" title="0">
        // client realisation
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package migratorConfig configures the migrator
package migratorConfig

import (
        "flag"
        "fmt"
        "os"

        "github.com/go-playground/validator/v10"
        "github.com/spf13/viper"
)

// MigratorConfig consists of fields for migrator configuration
type MigratorConfig struct {
        DB             DBConfig `yaml:"db"`
        MigrationsPath string   `yaml:"migrationsPath" validate:"required"`
}

// DBConfig consists of fields for database configuration
type DBConfig struct {
        Host     string `yaml:"host" validate:"required"`
        Port     int    `yaml:"port" validate:"required"`
        User     string `yaml:"user" validate:"required"`
        Password string `yaml:"password" validate:"required"`
        Database string `yaml:"database" validate:"required"`
}

// MustLoad loads the MigratorConfig from file
func MustLoad() *MigratorConfig <span class="cov0" title="0">{
        path := configPath()
        if path == "" </span><span class="cov0" title="0">{
                panic("config path is empty")</span>
        }

        <span class="cov0" title="0">viper.SetConfigFile(path)
        conf := &amp;MigratorConfig{}

        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to parse config: %w", err))</span>
        }

        <span class="cov0" title="0">fmt.Println(viper.Get("migrations_path"))

        err = viper.Unmarshal(conf)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to unmarshal config: %w", err))</span>
        }

        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(conf); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("missing requiered attributes: %w", err))</span>
        }

        <span class="cov0" title="0">return conf</span>
}

func configPath() string <span class="cov0" title="0">{
        var res string

        flag.StringVar(&amp;res, "c", "", "path to config file")
        flag.Parse()

        if res == "" </span><span class="cov0" title="0">{
                res = os.Getenv("MIGRATOR_CONFIG_PATH")
        }</span>

        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "errors"
        "fmt"

        "github.com/golang-migrate/migrate/v4"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        _ "github.com/golang-migrate/migrate/v4/source/github"
        _ "github.com/mattes/migrate/source/file"

        migratorConfig "github.com/vindosVP/go-pass/cmd/migrator/config"
        "github.com/vindosVP/go-pass/pkg/db"
)

func main() <span class="cov0" title="0">{

        conf := migratorConfig.MustLoad()
        m, err := migrate.New(
                fmt.Sprintf("file://%s", conf.MigrationsPath),
                db.PostgresDSN(conf.DB.Host, conf.DB.Port, conf.DB.User, conf.DB.Password, conf.DB.Database))

        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to connect database: %w", err))</span>
        }

        <span class="cov0" title="0">if err := m.Up(); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                        fmt.Println("no migrations to apply")
                        return
                }</span>
                <span class="cov0" title="0">panic(fmt.Errorf("failed to apply migrations: %w", err))</span>
        }

        <span class="cov0" title="0">fmt.Println("migrations applied")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package serverConfig configures the server
package serverConfig

import (
        "encoding/json"
        "flag"
        "fmt"
        "os"
        "time"

        "github.com/go-playground/validator/v10"
        "github.com/spf13/viper"

        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

// ServerConfig consists of fields for server configuration
type ServerConfig struct {
        Env          string     `yaml:"env" validate:"required"`
        DB           DBConfig   `yaml:"db"`
        GRPC         GRPCConfig `yaml:"grpc"`
        Auth         AuthConfig `yaml:"auth"`
        FileLocation string     `yaml:"fileLocation" validate:"required"`
}

// String turns the ServerConfig to string
func (s *ServerConfig) String() string <span class="cov0" title="0">{
        out, err := json.Marshal(s)

        if err != nil </span><span class="cov0" title="0">{
                sl.Err(fmt.Errorf("failed to marshal server config: %w", err))
        }</span>

        <span class="cov0" title="0">return string(out)</span>
}

// DBConfig consists of fields for database configuration
type DBConfig struct {
        Host     string `yaml:"host" validate:"required"`
        Port     int    `yaml:"port" validate:"required"`
        User     string `yaml:"user" validate:"required"`
        Password string `yaml:"password" validate:"required"`
        Database string `yaml:"database" validate:"required"`
}

// GRPCConfig consists of fields for grpc configuration
type GRPCConfig struct {
        Port    int           `yaml:"port" validate:"required"`
        Timeout time.Duration `yaml:"timeout" validate:"required"`
}

// AuthConfig consists of fields for authentication configuration
type AuthConfig struct {
        Secret   string        `yaml:"secret" validate:"required"`
        TokenTTL time.Duration `yaml:"tokenTTL" validate:"required"`
}

// MustLoad loads the ServerConfig from file
func MustLoad() *ServerConfig <span class="cov0" title="0">{
        path := configPath()
        if path == "" </span><span class="cov0" title="0">{
                panic("config path is empty")</span>
        }

        <span class="cov0" title="0">viper.SetConfigFile(path)
        conf := &amp;ServerConfig{}

        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to parse config: %w", err))</span>
        }

        <span class="cov0" title="0">err = viper.Unmarshal(conf)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("failed to unmarshal config: %w", err))</span>
        }

        <span class="cov0" title="0">validate := validator.New()
        if err := validate.Struct(conf); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Errorf("missing requiered attributes: %w", err))</span>
        }

        <span class="cov0" title="0">return conf</span>
}

func configPath() string <span class="cov0" title="0">{
        var res string

        flag.StringVar(&amp;res, "c", "", "path to config file")
        flag.Parse()

        if res == "" </span><span class="cov0" title="0">{
                res = os.Getenv("SERVER_CONFIG_PATH")
        }</span>

        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "log/slog"
        "os"
        "os/signal"
        "syscall"

        "github.com/jackc/pgx/v5/pgxpool"

        serverConfig "github.com/vindosVP/go-pass/cmd/server/config"
        "github.com/vindosVP/go-pass/internal/app"
        "github.com/vindosVP/go-pass/pkg/db"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

var (
        buildVersion = "N/A"
        buildDate    = "N/A"
        buildCommit  = "N/A"
)

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        printBuildInfo()
        conf := serverConfig.MustLoad()
        sl.SetupLogger(conf.Env)

        sl.Log.Info("Starting server...", slog.String("config", conf.String()))

        dsn := db.PostgresDSN(conf.DB.Host, conf.DB.Port, conf.DB.User, conf.DB.Password, conf.DB.Database)
        pool, err := pgxpool.New(ctx, dsn)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(fmt.Errorf("error connecting to database: %w", err))
        }</span>
        <span class="cov0" title="0">a := app.New(conf.GRPC.Port, pool, conf.Auth.TokenTTL, conf.Auth.Secret, conf.FileLocation)

        go func() </span><span class="cov0" title="0">{
                a.MustRun()
        }</span>()

        <span class="cov0" title="0">stop := make(chan os.Signal, 3)
        signal.Notify(stop, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT)

        &lt;-stop

        a.Stop()
        sl.Log.Info("Gracefully stopped")</span>
}

func printBuildInfo() <span class="cov0" title="0">{
        fmt.Printf("Build version: %s\n", buildVersion)
        fmt.Printf("Build date: %s\n", buildDate)
        fmt.Printf("Build commit: %s\n", buildCommit)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package app creates and works with the App
package app

import (
        "time"

        "github.com/jackc/pgx/v5/pgxpool"

        grpcapp "github.com/vindosVP/go-pass/internal/app/grpc"
        "github.com/vindosVP/go-pass/internal/services/auth"
        "github.com/vindosVP/go-pass/internal/services/passkeeper"
        "github.com/vindosVP/go-pass/internal/storage/postgres"
)

// App consist the grpc server
type App struct {
        grpcServer *grpcapp.App
}

// MustRun runs the app
func (a *App) MustRun() <span class="cov0" title="0">{
        a.grpcServer.MustRun()
}</span>

// Stop stops app
func (a *App) Stop() <span class="cov0" title="0">{
        a.grpcServer.Stop()
}</span>

// New creates the App instance
func New(port int, pool *pgxpool.Pool, tokenTTL time.Duration, secret string, fl string) *App <span class="cov0" title="0">{
        s := postgres.New(pool)
        a := auth.New(s, tokenTTL, secret)
        k := passkeeper.New(s, s, s, s, fl)
        grpcApp := grpcapp.New(port, secret, a, k)
        return &amp;App{
                grpcServer: grpcApp,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package grpcapp

import (
        "context"
        "fmt"
        "log/slog"
        "net"

        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/logging"
        "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/recovery"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        authgrpc "github.com/vindosVP/go-pass/internal/grpc/auth"
        passkeepergrpc "github.com/vindosVP/go-pass/internal/grpc/passkeeper"
        "github.com/vindosVP/go-pass/internal/interceptors"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

// App is a grpc app representation.
type App struct {
        grpcServer *grpc.Server
        port       int
}

// MustRun runs gRPC server and panics if any error occurs.
func (a *App) MustRun() <span class="cov0" title="0">{
        if err := a.Run(); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// Run runs gRPC server.
func (a *App) Run() error <span class="cov0" title="0">{
        l, err := net.Listen("tcp", fmt.Sprintf(":%d", a.port))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen: %w", err)
        }</span>
        <span class="cov0" title="0">sl.Log.Info("grpc server started", slog.String("addr", l.Addr().String()))
        if err := a.grpcServer.Serve(l); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Stop stops gRPC server.
func (a *App) Stop() <span class="cov0" title="0">{
        sl.Log.Info("stopping gRPC server", slog.Int("port", a.port))
        a.grpcServer.GracefulStop()
}</span>

// New creates a grpc app instance.
func New(port int, secret string, auth authgrpc.Auth, keeper passkeepergrpc.Keeper) *App <span class="cov0" title="0">{
        loggingOpts := []logging.Option{
                logging.WithLogOnEvents(
                        logging.PayloadReceived, logging.PayloadSent,
                ),
        }
        recoveryOpts := []recovery.Option{
                recovery.WithRecoveryHandler(func(p interface{}) (err error) </span><span class="cov0" title="0">{
                        sl.Log.Error("recovered from panic", slog.Any("panic", p))
                        return status.Errorf(codes.Internal, "internal error")
                }</span>),
        }
        <span class="cov0" title="0">grpcServer := grpc.NewServer(grpc.ChainUnaryInterceptor(
                recovery.UnaryServerInterceptor(recoveryOpts...),
                logging.UnaryServerInterceptor(InterceptorLogger(sl.Log), loggingOpts...),
                interceptors.NewAuthInterceptor(secret).Unary(),
        ), grpc.ChainStreamInterceptor(
                recovery.StreamServerInterceptor(recoveryOpts...),
                logging.StreamServerInterceptor(InterceptorLogger(sl.Log), loggingOpts...),
                interceptors.NewAuthInterceptor(secret).Stream()),
        )

        authgrpc.Register(grpcServer, auth)
        passkeepergrpc.Register(grpcServer, keeper)

        return &amp;App{
                grpcServer: grpcServer,
                port:       port,
        }</span>
}

// InterceptorLogger adapts slog logger to interceptor logger.
func InterceptorLogger(l *slog.Logger) logging.Logger <span class="cov0" title="0">{
        return logging.LoggerFunc(func(ctx context.Context, lvl logging.Level, msg string, fields ...any) </span><span class="cov0" title="0">{
                l.Log(ctx, slog.Level(lvl), msg, fields...)
        }</span>)
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package filemanager

import (
        "errors"
        "os"
        "path/filepath"
)

var ErrEOF = errors.New("EOF")

type FileSaver struct {
        filePath string
        outFile  *os.File
}

func NewFileSaver() *FileSaver <span class="cov0" title="0">{
        return &amp;FileSaver{}
}</span>

func (f *FileSaver) SetFile(fileName string, path string) error <span class="cov0" title="0">{
        f.filePath = filepath.Join(path, fileName)
        file, err := os.Create(f.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">f.outFile = file
        return nil</span>
}

func (f *FileSaver) IsFileSet() bool <span class="cov0" title="0">{
        return f.filePath != ""
}</span>

func (f *FileSaver) Write(chunk []byte) error <span class="cov0" title="0">{
        if f.outFile == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">_, err := f.outFile.Write(chunk)
        return err</span>
}

func (f *FileSaver) Close() error <span class="cov0" title="0">{
        return f.outFile.Close()
}</span>

type FileDeleter struct {
        filePath string
}

func NewFileDeleter() *FileDeleter <span class="cov8" title="1">{
        return &amp;FileDeleter{}
}</span>

func (f *FileDeleter) SetFile(fileName string, path string) <span class="cov8" title="1">{
        f.filePath = filepath.Join(path, fileName)
}</span>

func (f *FileDeleter) Delete() error <span class="cov8" title="1">{
        return os.Remove(f.filePath)
}</span>

type FileReader struct {
        filePath  string
        chunkSize int
        buf       []byte
        file      *os.File
        read      int
}

func NewFileReader(chunkSize int) *FileReader <span class="cov0" title="0">{
        return &amp;FileReader{chunkSize: chunkSize, buf: make([]byte, chunkSize)}
}</span>

func (f *FileReader) SetFile(fileName string, path string) error <span class="cov0" title="0">{
        f.filePath = filepath.Join(path, fileName)
        file, err := os.Open(f.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">f.file = file
        return nil</span>
}

func (f *FileReader) Next() bool <span class="cov0" title="0">{
        read, err := f.file.Read(f.buf)
        f.read = read
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (f *FileReader) Data() []byte <span class="cov0" title="0">{
        return f.buf[:f.read]
}</span>

func (f *FileReader) Close() error <span class="cov0" title="0">{
        return f.file.Close()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package authgrpc consists the auth grpc server
package authgrpc

import (
        "context"
        "errors"
        "log/slog"
        "net/mail"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/vindosVP/go-pass/internal/models"
        authv1 "github.com/vindosVP/go-pass/internal/proto/auth"
        "github.com/vindosVP/go-pass/internal/services/auth"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

// Auth is an authentication API interface
//
//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=Auth
type Auth interface {
        CreateUser(ctx context.Context, email string, pass string) (*models.User, error)
        Login(ctx context.Context, email string, pass string) (string, error)
}

type server struct {
        authv1.UnimplementedAuthServer
        auth Auth
}

// Register registers the auth service.
func Register(gRPCServer *grpc.Server, auth Auth) <span class="cov0" title="0">{
        authv1.RegisterAuthServer(gRPCServer, &amp;server{auth: auth})
}</span>

// Login logs in the user
func (s *server) Login(ctx context.Context, in *authv1.LoginRequest) (*authv1.LoginResponse, error) <span class="cov8" title="1">{

        lg := sl.Log.With(slog.String("email", in.Email))
        lg.Info("handling login")

        err, code, msg := validate(in.Email, in.Password)
        if err != nil </span><span class="cov8" title="1">{
                lg.Info(msg)
                return nil, status.Error(code, msg)
        }</span>
        <span class="cov8" title="1">token, err := s.auth.Login(ctx, in.Email, in.Password)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, auth.ErrInvalidCredentials) </span><span class="cov8" title="1">{
                        lg.Info("invalid email or password")
                        return nil, status.Error(codes.Unauthenticated, "invalid email or password")
                }</span>
                <span class="cov8" title="1">lg.Error("failed to login", sl.Err(err))
                return nil, status.Error(codes.Internal, "failed to login")</span>
        }

        <span class="cov8" title="1">lg.Info("logged in")
        return &amp;authv1.LoginResponse{Token: token}, nil</span>
}

// Register registers a new user
func (s *server) Register(ctx context.Context, in *authv1.RegisterRequest) (*authv1.RegisterResponse, error) <span class="cov8" title="1">{

        lg := sl.Log.With(slog.String("email", in.Email))
        lg.Info("handling register")

        err, code, msg := validate(in.Email, in.Password)
        if err != nil </span><span class="cov8" title="1">{
                lg.Info(msg)
                return nil, status.Error(code, msg)
        }</span>
        <span class="cov8" title="1">user, err := s.auth.CreateUser(ctx, in.Email, in.Password)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, auth.ErrUserAlreadyExists) </span><span class="cov8" title="1">{
                        lg.Info("user with this email already exists")
                        return nil, status.Error(codes.InvalidArgument, "user with this email already exists")
                }</span>
                <span class="cov8" title="1">lg.Error("failed to create user", sl.Err(err))
                return nil, status.Error(codes.Internal, "failed to create user")</span>
        }

        <span class="cov8" title="1">lg.Info("registered user")
        return &amp;authv1.RegisterResponse{UserId: int64(user.ID)}, nil</span>
}

func validate(email string, password string) (error, codes.Code, string) <span class="cov8" title="1">{
        errValidation := errors.New("user validation error")
        if email == "" </span><span class="cov8" title="1">{
                return errValidation, codes.InvalidArgument, "email is requiered"
        }</span>
        <span class="cov8" title="1">if !isValidEmail(email) </span><span class="cov8" title="1">{
                return errValidation, codes.InvalidArgument, "email is invalid"
        }</span>
        <span class="cov8" title="1">if password == "" </span><span class="cov8" title="1">{
                return errValidation, codes.InvalidArgument, "password is required"
        }</span>
        <span class="cov8" title="1">return nil, codes.OK, ""</span>
}

func isValidEmail(email string) bool <span class="cov8" title="1">{
        _, err := mail.ParseAddress(email)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        models "github.com/vindosVP/go-pass/internal/models"
)

// Auth is an autogenerated mock type for the Auth type
type Auth struct {
        mock.Mock
}

// CreateUser provides a mock function with given fields: ctx, email, pass
func (_m *Auth) CreateUser(ctx context.Context, email string, pass string) (*models.User, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, email, pass)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateUser")</span>
        }

        <span class="cov8" title="1">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email, pass)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, pass)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, pass)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// Login provides a mock function with given fields: ctx, email, pass
func (_m *Auth) Login(ctx context.Context, email string, pass string) (string, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, email, pass)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Login")</span>
        }

        <span class="cov8" title="1">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email, pass)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, pass)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, pass)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewAuth creates a new instance of Auth. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAuth(t interface {
        mock.TestingT
        Cleanup(func())
}) *Auth <span class="cov8" title="1">{
        mock := &amp;Auth{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        models "github.com/vindosVP/go-pass/internal/models"

        passkeeperv1 "github.com/vindosVP/go-pass/internal/proto/passkeeper"
)

// Keeper is an autogenerated mock type for the Keeper type
type Keeper struct {
        mock.Mock
}

// Delete provides a mock function with given fields: ctx, id, ownerID, t
func (_m *Keeper) Delete(ctx context.Context, id int, ownerID int, t models.EntityType) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, id, ownerID, t)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Delete")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int, int, models.EntityType) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id, ownerID, t)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// DownloadFile provides a mock function with given fields: id, ownerID, str
func (_m *Keeper) DownloadFile(id int, ownerID int, str passkeeperv1.PassKeeper_DownloadFileServer) error <span class="cov0" title="0">{
        ret := _m.Called(id, ownerID, str)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DownloadFile")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(int, int, passkeeperv1.PassKeeper_DownloadFileServer) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id, ownerID, str)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// List provides a mock function with given fields: ctx, ownerID
func (_m *Keeper) List(ctx context.Context, ownerID int) ([]*models.Entity, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, ownerID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for List")</span>
        }

        <span class="cov0" title="0">var r0 []*models.Entity
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]*models.Entity, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, ownerID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, int) []*models.Entity); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, ownerID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]*models.Entity)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, ownerID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Save provides a mock function with given fields: ctx, e
func (_m *Keeper) Save(ctx context.Context, e *models.Entity) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, e)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Save")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Entity) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, e)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *models.Entity) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, e)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *models.Entity) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, e)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// SaveFile provides a mock function with given fields: str
func (_m *Keeper) SaveFile(str passkeeperv1.PassKeeper_UploadFileServer) error <span class="cov0" title="0">{
        ret := _m.Called(str)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SaveFile")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(passkeeperv1.PassKeeper_UploadFileServer) error); ok </span><span class="cov0" title="0">{
                r0 = rf(str)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Update provides a mock function with given fields: ctx, e
func (_m *Keeper) Update(ctx context.Context, e *models.Entity) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, e)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Entity) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, e)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewKeeper creates a new instance of Keeper. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKeeper(t interface {
        mock.TestingT
        Cleanup(func())
}) *Keeper <span class="cov0" title="0">{
        mock := &amp;Keeper{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package passkeepergrpc

import (
        "context"
        "errors"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/vindosVP/go-pass/internal/models"
        passkeeperv1 "github.com/vindosVP/go-pass/internal/proto/passkeeper"
        "github.com/vindosVP/go-pass/internal/services/passkeeper"
        "github.com/vindosVP/go-pass/pkg/grpcmd"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

// Keeper represents the keeeper API.
//
//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=Keeper
type Keeper interface {
        Save(ctx context.Context, e *models.Entity) (int, error)
        Update(ctx context.Context, e *models.Entity) error
        Delete(ctx context.Context, id int, ownerID int, t models.EntityType) error
        List(ctx context.Context, ownerID int) ([]*models.Entity, error)
        SaveFile(str passkeeperv1.PassKeeper_UploadFileServer) error
        DownloadFile(id int, ownerID int, str passkeeperv1.PassKeeper_DownloadFileServer) error
}

type server struct {
        passkeeperv1.UnimplementedPassKeeperServer
        k Keeper
}

// Register registers the passkeeper service.
func Register(gRPCServer *grpc.Server, k Keeper) <span class="cov0" title="0">{
        passkeeperv1.RegisterPassKeeperServer(gRPCServer, &amp;server{k: k})
}</span>

// AddEntity adds the entity.
func (s server) AddEntity(ctx context.Context, in *passkeeperv1.AddEntityRequest) (*passkeeperv1.AddEntityResponse, error) <span class="cov0" title="0">{

        lg := sl.Log
        lg.Info("handling add entity request")

        uid, err := grpcmd.ExtractUID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "failed to extract uid: %v", err)
        }</span>

        <span class="cov0" title="0">e := grpcToDTO(in.Entity, uid)
        id, err := s.k.Save(ctx, e)
        if err != nil </span><span class="cov0" title="0">{
                lg.Error("failed to save entity", err)
                return nil, status.Errorf(codes.Internal, "failed to save entity")
        }</span>

        <span class="cov0" title="0">lg.Info("saved entity", slog.Int("id", id))
        return &amp;passkeeperv1.AddEntityResponse{Id: int64(id)}, nil</span>
}

// UpdateEntity updates the entity.
func (s server) UpdateEntity(ctx context.Context, in *passkeeperv1.UpdateEntityRequest) (*passkeeperv1.UpdateEntityResponse, error) <span class="cov0" title="0">{

        lg := sl.Log
        lg.Info("handling update entity request")

        uid, err := grpcmd.ExtractUID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "failed to extract uid: %v", err)
        }</span>

        <span class="cov0" title="0">e := grpcToDTO(in.Entity, uid)
        e.ID = int(in.Id)
        err = s.k.Update(ctx, e)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, passkeeper.ErrUnableToUpdateFile) </span><span class="cov0" title="0">{
                        lg.Info("unable to update file")
                        return nil, status.Errorf(codes.InvalidArgument, "unable to update file")
                }</span>
                <span class="cov0" title="0">lg.Error("failed to update entity", err)
                return nil, status.Errorf(codes.Internal, "failed to update entity")</span>
        }

        <span class="cov0" title="0">lg.Info("updated entity", slog.Int("id", e.ID))
        return &amp;passkeeperv1.UpdateEntityResponse{}, nil</span>
}

// DeleteEntity deletes the entity.
func (s server) DeleteEntity(ctx context.Context, in *passkeeperv1.DeleteEntityRequest) (*passkeeperv1.DeleteEntityResponse, error) <span class="cov0" title="0">{

        lg := sl.Log
        lg.Info("handling delete entity request")

        uid, err := grpcmd.ExtractUID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "failed to extract uid: %v", err)
        }</span>

        <span class="cov0" title="0">err = s.k.Delete(ctx, int(in.Id), uid, totype(in.Type))
        if err != nil </span><span class="cov0" title="0">{
                lg.Error("failed to delete entity", err)
                return nil, status.Errorf(codes.Internal, "failed to delete entity")
        }</span>
        <span class="cov0" title="0">lg.Info("deleted entity", slog.Int("id", int(in.Id)))
        return &amp;passkeeperv1.DeleteEntityResponse{}, nil</span>
}

// ListEntities lists all entities.
func (s server) ListEntities(ctx context.Context, _ *passkeeperv1.ListEntitiesRequest) (*passkeeperv1.ListEntitiesResponse, error) <span class="cov0" title="0">{

        lg := sl.Log
        lg.Info("handling list entities request")

        uid, err := grpcmd.ExtractUID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "failed to extract uid: %v", err)
        }</span>

        <span class="cov0" title="0">res, err := s.k.List(ctx, uid)
        if err != nil </span><span class="cov0" title="0">{
                lg.Error("failed to list entities", err)
                return nil, status.Errorf(codes.Internal, "failed to list entities")
        }</span>
        <span class="cov0" title="0">resp := &amp;passkeeperv1.ListEntitiesResponse{Entity: make([]*passkeeperv1.Entity, 0, len(res))}
        for _, e := range res </span><span class="cov0" title="0">{
                resp.Entity = append(resp.Entity, dtoToGRPC(e))
        }</span>
        <span class="cov0" title="0">return resp, nil</span>
}

// UploadFile uploads files to the server.
func (s server) UploadFile(str passkeeperv1.PassKeeper_UploadFileServer) error <span class="cov0" title="0">{
        return s.k.SaveFile(str)
}</span>

// DownloadFile downloads file from the server.
func (s server) DownloadFile(in *passkeeperv1.DownloadFileRequest, str passkeeperv1.PassKeeper_DownloadFileServer) error <span class="cov0" title="0">{
        uid, err := grpcmd.ExtractUID(str.Context())
        if err != nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.InvalidArgument, "failed to extract uid: %v", err)
        }</span>
        <span class="cov0" title="0">return s.k.DownloadFile(int(in.Id), uid, str)</span>
}

func dtoToGRPC(e *models.Entity) *passkeeperv1.Entity <span class="cov0" title="0">{

        var t passkeeperv1.Type
        switch e.Type </span>{
        case models.TypePassword:<span class="cov0" title="0">
                t = passkeeperv1.Type_PASSWORD</span>
        case models.TypeFile:<span class="cov0" title="0">
                t = passkeeperv1.Type_FILE</span>
        case models.TypeCard:<span class="cov0" title="0">
                t = passkeeperv1.Type_CARD</span>
        case models.TypeText:<span class="cov0" title="0">
                t = passkeeperv1.Type_TEXT</span>
        }

        <span class="cov0" title="0">return &amp;passkeeperv1.Entity{
                Id:         int64(e.ID),
                Type:       t,
                Login:      e.Login,
                Password:   e.Password,
                CardNumber: e.CardNumber,
                CardOwner:  e.CardOwner,
                CardCVC:    e.CardCVC,
                CardExp:    e.CardExp,
                Text:       e.Text,
                Filename:   e.Filename,
                Metadata:   e.Metadata,
        }</span>
}

func grpcToDTO(e *passkeeperv1.Entity, ownerID int) *models.Entity <span class="cov0" title="0">{

        var t models.EntityType
        switch e.Type </span>{
        case passkeeperv1.Type_PASSWORD:<span class="cov0" title="0">
                t = models.TypePassword</span>
        case passkeeperv1.Type_CARD:<span class="cov0" title="0">
                t = models.TypeCard</span>
        case passkeeperv1.Type_TEXT:<span class="cov0" title="0">
                t = models.TypeText</span>
        case passkeeperv1.Type_FILE:<span class="cov0" title="0">
                t = models.TypeFile</span>
        }

        <span class="cov0" title="0">return &amp;models.Entity{
                ID:         int(e.Id),
                OwnerID:    ownerID,
                Type:       t,
                Login:      e.Login,
                Password:   e.Password,
                CardNumber: e.CardNumber,
                CardOwner:  e.CardOwner,
                CardCVC:    e.CardCVC,
                CardExp:    e.CardExp,
                Text:       e.Text,
                Filename:   e.Filename,
                Metadata:   e.Metadata,
        }</span>
}

func totype(grpcType passkeeperv1.Type) models.EntityType <span class="cov0" title="0">{
        switch grpcType </span>{
        case passkeeperv1.Type_PASSWORD:<span class="cov0" title="0">
                return models.TypePassword</span>
        case passkeeperv1.Type_CARD:<span class="cov0" title="0">
                return models.TypeCard</span>
        case passkeeperv1.Type_TEXT:<span class="cov0" title="0">
                return models.TypeText</span>
        default:<span class="cov0" title="0">
                return models.TypeFile</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package interceptors

import (
        "context"
        "strconv"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"

        "github.com/vindosVP/go-pass/internal/jwt"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

type AuthInterceptor struct {
        secret string
}

func NewAuthInterceptor(secret string) *AuthInterceptor <span class="cov0" title="0">{
        return &amp;AuthInterceptor{secret: secret}
}</span>

var openedMethods = []string{"/auth.Auth/Login", "/auth.Auth/Register"}

type wrappedStream struct {
        grpc.ServerStream
        ctx context.Context
}

func (w *wrappedStream) Context() context.Context <span class="cov0" title="0">{
        return w.ctx
}</span>

func (w *wrappedStream) SetContext(ctx context.Context) <span class="cov0" title="0">{
        w.ctx = ctx
}</span>

func (w *wrappedStream) RecvMsg(m interface{}) error <span class="cov0" title="0">{
        return w.ServerStream.RecvMsg(m)
}</span>

func (w *wrappedStream) SendMsg(m interface{}) error <span class="cov0" title="0">{
        return w.ServerStream.SendMsg(m)
}</span>

type StreamContextWrapper interface {
        grpc.ServerStream
        SetContext(context.Context)
}

func (a *AuthInterceptor) Unary() grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                req interface{},
                info *grpc.UnaryServerInfo,
                handler grpc.UnaryHandler,
        ) (interface{}, error) </span><span class="cov0" title="0">{

                lg := sl.Log

                for _, v := range openedMethods </span><span class="cov0" title="0">{
                        if v == info.FullMethod </span><span class="cov0" title="0">{
                                return handler(ctx, req)
                        }</span>
                }

                <span class="cov0" title="0">md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        lg.Info("missing token")
                        return nil, status.Errorf(codes.Unauthenticated, "missing token")
                }</span>
                <span class="cov0" title="0">t := md.Get("token")
                if len(t) != 1 </span><span class="cov0" title="0">{
                        lg.Info("wrong token format")
                        return nil, status.Errorf(codes.Unauthenticated, "wrong token format")
                }</span>
                <span class="cov0" title="0">token := t[0]

                email, uid, err := jwt.VerifyToken(token, a.secret)
                if err != nil </span><span class="cov0" title="0">{
                        lg.Info("invalid token")
                        return nil, status.Errorf(codes.Unauthenticated, "invalid token")
                }</span>

                <span class="cov0" title="0">newMD := map[string]string{
                        "email": email,
                        "uid":   strconv.Itoa(uid),
                }

                return handler(metadata.NewIncomingContext(ctx, metadata.New(newMD)), req)</span>
        }
}

func (a *AuthInterceptor) Stream() grpc.StreamServerInterceptor <span class="cov0" title="0">{
        return func(
                srv interface{},
                stream grpc.ServerStream,
                info *grpc.StreamServerInfo,
                handler grpc.StreamHandler,
        ) error </span><span class="cov0" title="0">{

                lg := sl.Log

                for _, v := range openedMethods </span><span class="cov0" title="0">{
                        if v == info.FullMethod </span><span class="cov0" title="0">{
                                return handler(srv, stream)
                        }</span>
                }

                <span class="cov0" title="0">md, ok := metadata.FromIncomingContext(stream.Context())
                if !ok </span><span class="cov0" title="0">{
                        lg.Info("missing token")
                        return status.Errorf(codes.Unauthenticated, "missing token")
                }</span>
                <span class="cov0" title="0">t := md.Get("token")
                if len(t) != 1 </span><span class="cov0" title="0">{
                        lg.Info("wrong token format")
                        return status.Errorf(codes.Unauthenticated, "wrong token format")
                }</span>
                <span class="cov0" title="0">token := t[0]

                email, uid, err := jwt.VerifyToken(token, a.secret)
                if err != nil </span><span class="cov0" title="0">{
                        lg.Info("invalid token")
                        return status.Errorf(codes.Unauthenticated, "invalid token")
                }</span>

                <span class="cov0" title="0">newMD := map[string]string{
                        "email": email,
                        "uid":   strconv.Itoa(uid),
                }
                newCtx := metadata.NewIncomingContext(stream.Context(), metadata.New(newMD))

                return handler(srv, &amp;wrappedStream{stream, newCtx})</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package jwt works with jwt-tokens
package jwt

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"

        "github.com/vindosVP/go-pass/internal/models"
)

// NewToken creates new JWT token for given user.
func NewToken(user *models.User, duration time.Duration, secret string) (string, error) <span class="cov8" title="1">{
        token := jwt.New(jwt.SigningMethodHS256)

        claims := token.Claims.(jwt.MapClaims)
        claims["uid"] = user.ID
        claims["email"] = user.Email
        claims["exp"] = time.Now().Add(duration).Unix()

        tokenString, err := token.SignedString([]byte(secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}

// VerifyToken verifies users token.
func VerifyToken(tokenString string, secret string) (string, int, error) <span class="cov8" title="1">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return []byte(secret), nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("invalid token: %w", err)
        }</span>
        <span class="cov8" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("invalid token: %w", err)
        }</span>
        <span class="cov8" title="1">email, ok := claims["email"].(string)
        if !ok </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("failed to extract email from token")
        }</span>
        <span class="cov8" title="1">uid, ok := claims["uid"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("failed to extract uid from token")
        }</span>
        <span class="cov8" title="1">return email, int(uid), nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package models consists of data models.
package models

import (
        "time"
)

// User represents the application user.
type User struct {
        ID        int       `json:"id" db:"id"`
        Email     string    `json:"email" db:"email"`
        PassHash  []byte    `json:"-" db:"hashed_password"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
}

// Password represents the login-password pair.
type Password struct {
        ID        int       `json:"id" db:"id"`
        OwnerID   int       `json:"owner_id" db:"owner_id"`
        Login     string    `json:"login" db:"login"`
        Password  string    `json:"password" db:"password"`
        Metadata  string    `json:"metadata" db:"metadata"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
}

// ToEntity transforms password model to dto entity.
func (p *Password) ToEntity() *Entity <span class="cov0" title="0">{
        return &amp;Entity{
                ID:       p.ID,
                OwnerID:  p.OwnerID,
                Type:     TypePassword,
                Login:    p.Login,
                Password: p.Password,
                Metadata: p.Metadata,
        }
}</span>

// Card represents the bank card.
type Card struct {
        ID        int       `json:"id" db:"id"`
        OwnerID   int       `json:"owner_id" db:"owner_id"`
        Number    string    `json:"number" db:"number"`
        CVC       string    `json:"cvc" db:"cvc"`
        Owner     string    `json:"owner" db:"owner"`
        Date      string    `json:"date" db:"date"`
        Metadata  string    `json:"metadata" db:"metadata"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
}

// ToEntity transforms card model to dto entity.
func (c *Card) ToEntity() *Entity <span class="cov0" title="0">{
        return &amp;Entity{
                ID:         c.ID,
                OwnerID:    c.OwnerID,
                Type:       TypeCard,
                CardNumber: c.Number,
                CardOwner:  c.Owner,
                CardCVC:    c.CVC,
                CardExp:    c.Date,
                Metadata:   c.Metadata,
        }
}</span>

// Text represents the text information.
type Text struct {
        ID        int       `json:"id" db:"id"`
        OwnerID   int       `json:"owner_id" db:"owner_id"`
        Text      string    `json:"text" db:"text"`
        Metadata  string    `json:"metadata" db:"metadata"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
}

// ToEntity transforms text model to dto entity.
func (t *Text) ToEntity() *Entity <span class="cov0" title="0">{
        return &amp;Entity{
                ID:      t.ID,
                OwnerID: t.OwnerID,
                Type:    TypeText,
                Text:    t.Text,
        }
}</span>

// File represents the text uploaded file.
type File struct {
        ID        int       `json:"id" db:"id"`
        OwnerID   int       `json:"owner_id" db:"owner_id"`
        FileName  string    `json:"filename" db:"filename"`
        Metadata  string    `json:"metadata" db:"metadata"`
        CreatedAt time.Time `json:"created_at" db:"created_at"`
}

// ToEntity transforms file model to dto entity.
func (f *File) ToEntity() *Entity <span class="cov0" title="0">{
        return &amp;Entity{
                ID:       f.ID,
                OwnerID:  f.OwnerID,
                Type:     TypeFile,
                Metadata: f.Metadata,
                Filename: f.FileName,
        }
}</span>

// EntityType is the Entity type.
type EntityType string

const (
        TypePassword = EntityType("PASSWORD")
        TypeCard     = EntityType("CARD")
        TypeText     = EntityType("TEXT")
        TypeFile     = EntityType("FILE")
)

// Entity represents the entity DTO.
type Entity struct {
        ID         int
        OwnerID    int
        Type       EntityType
        Login      string
        Password   string
        CardNumber string
        CardOwner  string
        CardCVC    string
        CardExp    string
        Text       string
        Filename   string
        Metadata   string
}

// ToPassword transforms entity to the password model.
func (e *Entity) ToPassword() *Password <span class="cov8" title="1">{
        return &amp;Password{
                ID:       e.ID,
                OwnerID:  e.OwnerID,
                Login:    e.Login,
                Password: e.Password,
                Metadata: e.Metadata,
        }
}</span>

// ToCard transforms entity to the card model.
func (e *Entity) ToCard() *Card <span class="cov8" title="1">{
        return &amp;Card{
                ID:       e.ID,
                OwnerID:  e.OwnerID,
                Number:   e.CardNumber,
                CVC:      e.CardCVC,
                Owner:    e.CardOwner,
                Date:     e.CardExp,
                Metadata: e.Metadata,
        }
}</span>

// ToText transforms entity to the text model.
func (e *Entity) ToText() *Text <span class="cov8" title="1">{
        return &amp;Text{
                ID:       e.ID,
                OwnerID:  e.OwnerID,
                Text:     e.Text,
                Metadata: e.Metadata,
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        v4.25.0
// source: auth.proto

package authv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// RegisterRequest is a register handler request
type RegisterRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email    string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`       // Email of the user to register.
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"` // Password of the user to register.
}

func (x *RegisterRequest) Reset() <span class="cov0" title="0">{
        *x = RegisterRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RegisterRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterRequest.ProtoReflect.Descriptor instead.
func (*RegisterRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{0}
}</span>

func (x *RegisterRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RegisterRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// RegisterRequest is a register handler request
type RegisterResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        UserId int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"` // User ID of the registered user.
}

func (x *RegisterResponse) Reset() <span class="cov0" title="0">{
        *x = RegisterResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RegisterResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RegisterResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RegisterResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RegisterResponse.ProtoReflect.Descriptor instead.
func (*RegisterResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{1}
}</span>

func (x *RegisterResponse) GetUserId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// LoginRequest is a login handler request
type LoginRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Email    string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`       // Email of the user to login.
        Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"` // Password of the user to login.
}

func (x *LoginRequest) Reset() <span class="cov0" title="0">{
        *x = LoginRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginRequest.ProtoReflect.Descriptor instead.
func (*LoginRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{2}
}</span>

func (x *LoginRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoginRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// LoginResponse is a login handler response
type LoginResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"` // Auth token of the logged in user.
}

func (x *LoginResponse) Reset() <span class="cov0" title="0">{
        *x = LoginResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_auth_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_auth_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResponse.ProtoReflect.Descriptor instead.
func (*LoginResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_auth_proto_rawDescGZIP(), []int{3}
}</span>

func (x *LoginResponse) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_auth_proto protoreflect.FileDescriptor

var file_auth_proto_rawDesc = []byte{
        0x0a, 0x0a, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x04, 0x61, 0x75,
        0x74, 0x68, 0x22, 0x43, 0x0a, 0x0f, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70,
        0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70,
        0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x2b, 0x0a, 0x10, 0x52, 0x65, 0x67, 0x69, 0x73,
        0x74, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x17, 0x0a, 0x07, 0x75,
        0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x06, 0x75, 0x73,
        0x65, 0x72, 0x49, 0x64, 0x22, 0x40, 0x0a, 0x0c, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61,
        0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61,
        0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x22, 0x25, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x32, 0x73, 0x0a,
        0x04, 0x41, 0x75, 0x74, 0x68, 0x12, 0x39, 0x0a, 0x08, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
        0x72, 0x12, 0x15, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
        0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x16, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e,
        0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x12, 0x30, 0x0a, 0x05, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x12, 0x2e, 0x61, 0x75, 0x74, 0x68,
        0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x13, 0x2e,
        0x61, 0x75, 0x74, 0x68, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x42, 0x27, 0x5a, 0x25, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
        0x2f, 0x76, 0x69, 0x6e, 0x64, 0x6f, 0x73, 0x56, 0x50, 0x2f, 0x67, 0x6f, 0x2d, 0x70, 0x61, 0x73,
        0x73, 0x2f, 0x76, 0x31, 0x3b, 0x61, 0x75, 0x74, 0x68, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x33,
}

var (
        file_auth_proto_rawDescOnce sync.Once
        file_auth_proto_rawDescData = file_auth_proto_rawDesc
)

func file_auth_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_auth_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_auth_proto_rawDescData = protoimpl.X.CompressGZIP(file_auth_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_auth_proto_rawDescData</span>
}

var file_auth_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_auth_proto_goTypes = []interface{}{
        (*RegisterRequest)(nil),  // 0: auth.RegisterRequest
        (*RegisterResponse)(nil), // 1: auth.RegisterResponse
        (*LoginRequest)(nil),     // 2: auth.LoginRequest
        (*LoginResponse)(nil),    // 3: auth.LoginResponse
}
var file_auth_proto_depIdxs = []int32{
        0, // 0: auth.Auth.Register:input_type -&gt; auth.RegisterRequest
        2, // 1: auth.Auth.Login:input_type -&gt; auth.LoginRequest
        1, // 2: auth.Auth.Register:output_type -&gt; auth.RegisterResponse
        3, // 3: auth.Auth.Login:output_type -&gt; auth.LoginResponse
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_auth_proto_init() }</span>
func file_auth_proto_init() <span class="cov8" title="1">{
        if File_auth_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_auth_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RegisterRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RegisterResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoginRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_auth_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoginResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_auth_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_auth_proto_goTypes,
                DependencyIndexes: file_auth_proto_depIdxs,
                MessageInfos:      file_auth_proto_msgTypes,
        }.Build()
        File_auth_proto = out.File
        file_auth_proto_rawDesc = nil
        file_auth_proto_goTypes = nil
        file_auth_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v4.25.0
// source: auth.proto

package authv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
        Auth_Register_FullMethodName = "/auth.Auth/Register"
        Auth_Login_FullMethodName    = "/auth.Auth/Login"
)

// AuthClient is the client API for Auth service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthClient interface {
        // Register registers a new user.
        Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
        // Login logs in a user and returns an auth token.
        Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
}

type authClient struct {
        cc grpc.ClientConnInterface
}

func NewAuthClient(cc grpc.ClientConnInterface) AuthClient <span class="cov0" title="0">{
        return &amp;authClient{cc}
}</span>

func (c *authClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RegisterResponse)
        err := c.cc.Invoke(ctx, Auth_Register_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *authClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(LoginResponse)
        err := c.cc.Invoke(ctx, Auth_Login_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AuthServer is the server API for Auth service.
// All implementations must embed UnimplementedAuthServer
// for forward compatibility
type AuthServer interface {
        // Register registers a new user.
        Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
        // Login logs in a user and returns an auth token.
        Login(context.Context, *LoginRequest) (*LoginResponse, error)
        mustEmbedUnimplementedAuthServer()
}

// UnimplementedAuthServer must be embedded to have forward compatible implementations.
type UnimplementedAuthServer struct {
}

func (UnimplementedAuthServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}</span>
func (UnimplementedAuthServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}</span>
func (UnimplementedAuthServer) mustEmbedUnimplementedAuthServer() {<span class="cov0" title="0">}</span>

// UnsafeAuthServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServer will
// result in compilation errors.
type UnsafeAuthServer interface {
        mustEmbedUnimplementedAuthServer()
}

func RegisterAuthServer(s grpc.ServiceRegistrar, srv AuthServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;Auth_ServiceDesc, srv)
}</span>

func _Auth_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RegisterRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServer).Register(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Auth_Register_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServer).Register(ctx, req.(*RegisterRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Auth_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AuthServer).Login(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Auth_Login_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AuthServer).Login(ctx, req.(*LoginRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Auth_ServiceDesc is the grpc.ServiceDesc for Auth service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Auth_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "auth.Auth",
        HandlerType: (*AuthServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Register",
                        Handler:    _Auth_Register_Handler,
                },
                {
                        MethodName: "Login",
                        Handler:    _Auth_Login_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "auth.proto",
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.34.1
//         protoc        v4.25.0
// source: passkeeper.proto

package passkeeperv1

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Type int32

const (
        Type_PASSWORD Type = 0
        Type_CARD     Type = 1
        Type_TEXT     Type = 2
        Type_FILE     Type = 3
)

// Enum value maps for Type.
var (
        Type_name = map[int32]string{
                0: "PASSWORD",
                1: "CARD",
                2: "TEXT",
                3: "FILE",
        }
        Type_value = map[string]int32{
                "PASSWORD": 0,
                "CARD":     1,
                "TEXT":     2,
                "FILE":     3,
        }
)

func (x Type) Enum() *Type <span class="cov0" title="0">{
        p := new(Type)
        *p = x
        return p
}</span>

func (x Type) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Type) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_passkeeper_proto_enumTypes[0].Descriptor()
}</span>

func (Type) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_passkeeper_proto_enumTypes[0]
}</span>

func (x Type) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use Type.Descriptor instead.
func (Type) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{0}
}</span>

type Entity struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id         int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Type       Type   `protobuf:"varint,3,opt,name=type,proto3,enum=auth.Type" json:"type,omitempty"`
        Login      string `protobuf:"bytes,4,opt,name=login,proto3" json:"login,omitempty"`
        Password   string `protobuf:"bytes,5,opt,name=password,proto3" json:"password,omitempty"`
        CardNumber string `protobuf:"bytes,6,opt,name=cardNumber,proto3" json:"cardNumber,omitempty"`
        CardOwner  string `protobuf:"bytes,7,opt,name=cardOwner,proto3" json:"cardOwner,omitempty"`
        CardCVC    string `protobuf:"bytes,8,opt,name=cardCVC,proto3" json:"cardCVC,omitempty"`
        CardExp    string `protobuf:"bytes,9,opt,name=cardExp,proto3" json:"cardExp,omitempty"`
        Text       string `protobuf:"bytes,10,opt,name=text,proto3" json:"text,omitempty"`
        Filename   string `protobuf:"bytes,11,opt,name=filename,proto3" json:"filename,omitempty"`
        Metadata   string `protobuf:"bytes,12,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (x *Entity) Reset() <span class="cov0" title="0">{
        *x = Entity{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Entity) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Entity) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Entity) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Entity.ProtoReflect.Descriptor instead.
func (*Entity) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Entity) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Entity) GetType() Type <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return Type_PASSWORD</span>
}

func (x *Entity) GetLogin() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Login
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Entity) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Entity) GetCardNumber() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CardNumber
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Entity) GetCardOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CardOwner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Entity) GetCardCVC() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CardCVC
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Entity) GetCardExp() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CardExp
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Entity) GetText() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Text
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Entity) GetFilename() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filename
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Entity) GetMetadata() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type AddEntityRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Entity *Entity `protobuf:"bytes,1,opt,name=entity,proto3" json:"entity,omitempty"`
}

func (x *AddEntityRequest) Reset() <span class="cov0" title="0">{
        *x = AddEntityRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AddEntityRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddEntityRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddEntityRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddEntityRequest.ProtoReflect.Descriptor instead.
func (*AddEntityRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{1}
}</span>

func (x *AddEntityRequest) GetEntity() *Entity <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entity
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddEntityResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *AddEntityResponse) Reset() <span class="cov0" title="0">{
        *x = AddEntityResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *AddEntityResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddEntityResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddEntityResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddEntityResponse.ProtoReflect.Descriptor instead.
func (*AddEntityResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{2}
}</span>

func (x *AddEntityResponse) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdateEntityRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id     int64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Entity *Entity `protobuf:"bytes,2,opt,name=entity,proto3" json:"entity,omitempty"`
}

func (x *UpdateEntityRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateEntityRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateEntityRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateEntityRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateEntityRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateEntityRequest.ProtoReflect.Descriptor instead.
func (*UpdateEntityRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{3}
}</span>

func (x *UpdateEntityRequest) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UpdateEntityRequest) GetEntity() *Entity <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entity
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateEntityResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *UpdateEntityResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateEntityResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UpdateEntityResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateEntityResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateEntityResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateEntityResponse.ProtoReflect.Descriptor instead.
func (*UpdateEntityResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{4}
}</span>

type DeleteEntityRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id   int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
        Type Type  `protobuf:"varint,2,opt,name=type,proto3,enum=auth.Type" json:"type,omitempty"`
}

func (x *DeleteEntityRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteEntityRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteEntityRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteEntityRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteEntityRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteEntityRequest.ProtoReflect.Descriptor instead.
func (*DeleteEntityRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{5}
}</span>

func (x *DeleteEntityRequest) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DeleteEntityRequest) GetType() Type <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return Type_PASSWORD</span>
}

type DeleteEntityResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *DeleteEntityResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteEntityResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DeleteEntityResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteEntityResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteEntityResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteEntityResponse.ProtoReflect.Descriptor instead.
func (*DeleteEntityResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{6}
}</span>

type ListEntitiesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *ListEntitiesRequest) Reset() <span class="cov0" title="0">{
        *x = ListEntitiesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListEntitiesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListEntitiesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListEntitiesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListEntitiesRequest.ProtoReflect.Descriptor instead.
func (*ListEntitiesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{7}
}</span>

type ListEntitiesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Entity []*Entity `protobuf:"bytes,1,rep,name=entity,proto3" json:"entity,omitempty"`
}

func (x *ListEntitiesResponse) Reset() <span class="cov0" title="0">{
        *x = ListEntitiesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ListEntitiesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListEntitiesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListEntitiesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListEntitiesResponse.ProtoReflect.Descriptor instead.
func (*ListEntitiesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{8}
}</span>

func (x *ListEntitiesResponse) GetEntity() []*Entity <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entity
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UploadFileRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Chunk    []byte `protobuf:"bytes,1,opt,name=chunk,proto3" json:"chunk,omitempty"`
        Filename string `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty"`
        Metadata string `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (x *UploadFileRequest) Reset() <span class="cov0" title="0">{
        *x = UploadFileRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UploadFileRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadFileRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadFileRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadFileRequest.ProtoReflect.Descriptor instead.
func (*UploadFileRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{9}
}</span>

func (x *UploadFileRequest) GetChunk() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Chunk
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UploadFileRequest) GetFilename() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filename
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UploadFileRequest) GetMetadata() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UploadFileResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *UploadFileResponse) Reset() <span class="cov0" title="0">{
        *x = UploadFileResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UploadFileResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UploadFileResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UploadFileResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UploadFileResponse.ProtoReflect.Descriptor instead.
func (*UploadFileResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{10}
}</span>

func (x *UploadFileResponse) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DownloadFileRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *DownloadFileRequest) Reset() <span class="cov0" title="0">{
        *x = DownloadFileRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DownloadFileRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DownloadFileRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DownloadFileRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DownloadFileRequest.ProtoReflect.Descriptor instead.
func (*DownloadFileRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{11}
}</span>

func (x *DownloadFileRequest) GetId() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type DownloadFileResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Filename string `protobuf:"bytes,1,opt,name=filename,proto3" json:"filename,omitempty"`
        Chunk    []byte `protobuf:"bytes,2,opt,name=chunk,proto3" json:"chunk,omitempty"`
}

func (x *DownloadFileResponse) Reset() <span class="cov0" title="0">{
        *x = DownloadFileResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_passkeeper_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DownloadFileResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DownloadFileResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DownloadFileResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_passkeeper_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DownloadFileResponse.ProtoReflect.Descriptor instead.
func (*DownloadFileResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_passkeeper_proto_rawDescGZIP(), []int{12}
}</span>

func (x *DownloadFileResponse) GetFilename() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filename
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DownloadFileResponse) GetChunk() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Chunk
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_passkeeper_proto protoreflect.FileDescriptor

var file_passkeeper_proto_rawDesc = []byte{
        0x0a, 0x10, 0x70, 0x61, 0x73, 0x73, 0x6b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x12, 0x04, 0x61, 0x75, 0x74, 0x68, 0x22, 0xa8, 0x02, 0x0a, 0x06, 0x45, 0x6e, 0x74,
        0x69, 0x74, 0x79, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52,
        0x02, 0x69, 0x64, 0x12, 0x1e, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x0e, 0x32, 0x0a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74,
        0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x61, 0x73,
        0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x1e, 0x0a, 0x0a, 0x63, 0x61, 0x72, 0x64, 0x4e, 0x75, 0x6d,
        0x62, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x63, 0x61, 0x72, 0x64, 0x4e,
        0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x1c, 0x0a, 0x09, 0x63, 0x61, 0x72, 0x64, 0x4f, 0x77, 0x6e,
        0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x63, 0x61, 0x72, 0x64, 0x4f, 0x77,
        0x6e, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x61, 0x72, 0x64, 0x43, 0x56, 0x43, 0x18, 0x08,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x61, 0x72, 0x64, 0x43, 0x56, 0x43, 0x12, 0x18, 0x0a,
        0x07, 0x63, 0x61, 0x72, 0x64, 0x45, 0x78, 0x70, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
        0x63, 0x61, 0x72, 0x64, 0x45, 0x78, 0x70, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18,
        0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x66,
        0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66,
        0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64,
        0x61, 0x74, 0x61, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64,
        0x61, 0x74, 0x61, 0x22, 0x38, 0x0a, 0x10, 0x41, 0x64, 0x64, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x24, 0x0a, 0x06, 0x65, 0x6e, 0x74, 0x69, 0x74,
        0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x45,
        0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x06, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x22, 0x23, 0x0a,
        0x11, 0x41, 0x64, 0x64, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
        0x73, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02,
        0x69, 0x64, 0x22, 0x4b, 0x0a, 0x13, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x45, 0x6e, 0x74, 0x69,
        0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x24, 0x0a, 0x06, 0x65, 0x6e, 0x74,
        0x69, 0x74, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x61, 0x75, 0x74, 0x68,
        0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x06, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x22,
        0x16, 0x0a, 0x14, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x45, 0x0a, 0x13, 0x44, 0x65, 0x6c, 0x65, 0x74,
        0x65, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e,
        0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1e,
        0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0a, 0x2e, 0x61,
        0x75, 0x74, 0x68, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x22, 0x16,
        0x0a, 0x14, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x15, 0x0a, 0x13, 0x4c, 0x69, 0x73, 0x74, 0x45, 0x6e,
        0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x3c, 0x0a,
        0x14, 0x4c, 0x69, 0x73, 0x74, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x24, 0x0a, 0x06, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18,
        0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x45, 0x6e, 0x74,
        0x69, 0x74, 0x79, 0x52, 0x06, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x22, 0x61, 0x0a, 0x11, 0x55,
        0x70, 0x6c, 0x6f, 0x61, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x14, 0x0a, 0x05, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52,
        0x05, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x12, 0x1a, 0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61,
        0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x22, 0x24,
        0x0a, 0x12, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03,
        0x52, 0x02, 0x69, 0x64, 0x22, 0x25, 0x0a, 0x13, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64,
        0x46, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x69,
        0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x52, 0x02, 0x69, 0x64, 0x22, 0x48, 0x0a, 0x14, 0x44,
        0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x12,
        0x14, 0x0a, 0x05, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05,
        0x63, 0x68, 0x75, 0x6e, 0x6b, 0x2a, 0x32, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0c, 0x0a,
        0x08, 0x50, 0x41, 0x53, 0x53, 0x57, 0x4f, 0x52, 0x44, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x43,
        0x41, 0x52, 0x44, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x54, 0x45, 0x58, 0x54, 0x10, 0x02, 0x12,
        0x08, 0x0a, 0x04, 0x46, 0x49, 0x4c, 0x45, 0x10, 0x03, 0x32, 0xab, 0x03, 0x0a, 0x0a, 0x50, 0x61,
        0x73, 0x73, 0x4b, 0x65, 0x65, 0x70, 0x65, 0x72, 0x12, 0x3c, 0x0a, 0x09, 0x41, 0x64, 0x64, 0x45,
        0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x16, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x41, 0x64, 0x64,
        0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x17, 0x2e,
        0x61, 0x75, 0x74, 0x68, 0x2e, 0x41, 0x64, 0x64, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x45, 0x0a, 0x0c, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x19, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x55, 0x70,
        0x64, 0x61, 0x74, 0x65, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x1a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x45,
        0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x45, 0x0a,
        0x0c, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x19, 0x2e,
        0x61, 0x75, 0x74, 0x68, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x45, 0x6e, 0x74, 0x69, 0x74,
        0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e,
        0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x45, 0x0a, 0x0c, 0x4c, 0x69, 0x73, 0x74, 0x45, 0x6e, 0x74, 0x69,
        0x74, 0x69, 0x65, 0x73, 0x12, 0x19, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x4c, 0x69, 0x73, 0x74,
        0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
        0x1a, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x45, 0x6e, 0x74, 0x69, 0x74,
        0x69, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x41, 0x0a, 0x0a, 0x55,
        0x70, 0x6c, 0x6f, 0x61, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x17, 0x2e, 0x61, 0x75, 0x74, 0x68,
        0x2e, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x18, 0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64,
        0x46, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x28, 0x01, 0x12, 0x47,
        0x0a, 0x0c, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x19,
        0x2e, 0x61, 0x75, 0x74, 0x68, 0x2e, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x46, 0x69,
        0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1a, 0x2e, 0x61, 0x75, 0x74, 0x68,
        0x2e, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x73,
        0x70, 0x6f, 0x6e, 0x73, 0x65, 0x30, 0x01, 0x42, 0x2d, 0x5a, 0x2b, 0x67, 0x69, 0x74, 0x68, 0x75,
        0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x76, 0x69, 0x6e, 0x64, 0x6f, 0x73, 0x56, 0x50, 0x2f, 0x67,
        0x6f, 0x2d, 0x70, 0x61, 0x73, 0x73, 0x2f, 0x76, 0x31, 0x3b, 0x70, 0x61, 0x73, 0x73, 0x6b, 0x65,
        0x65, 0x70, 0x65, 0x72, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_passkeeper_proto_rawDescOnce sync.Once
        file_passkeeper_proto_rawDescData = file_passkeeper_proto_rawDesc
)

func file_passkeeper_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_passkeeper_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_passkeeper_proto_rawDescData = protoimpl.X.CompressGZIP(file_passkeeper_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_passkeeper_proto_rawDescData</span>
}

var file_passkeeper_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_passkeeper_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_passkeeper_proto_goTypes = []interface{}{
        (Type)(0),                    // 0: auth.Type
        (*Entity)(nil),               // 1: auth.Entity
        (*AddEntityRequest)(nil),     // 2: auth.AddEntityRequest
        (*AddEntityResponse)(nil),    // 3: auth.AddEntityResponse
        (*UpdateEntityRequest)(nil),  // 4: auth.UpdateEntityRequest
        (*UpdateEntityResponse)(nil), // 5: auth.UpdateEntityResponse
        (*DeleteEntityRequest)(nil),  // 6: auth.DeleteEntityRequest
        (*DeleteEntityResponse)(nil), // 7: auth.DeleteEntityResponse
        (*ListEntitiesRequest)(nil),  // 8: auth.ListEntitiesRequest
        (*ListEntitiesResponse)(nil), // 9: auth.ListEntitiesResponse
        (*UploadFileRequest)(nil),    // 10: auth.UploadFileRequest
        (*UploadFileResponse)(nil),   // 11: auth.UploadFileResponse
        (*DownloadFileRequest)(nil),  // 12: auth.DownloadFileRequest
        (*DownloadFileResponse)(nil), // 13: auth.DownloadFileResponse
}
var file_passkeeper_proto_depIdxs = []int32{
        0,  // 0: auth.Entity.type:type_name -&gt; auth.Type
        1,  // 1: auth.AddEntityRequest.entity:type_name -&gt; auth.Entity
        1,  // 2: auth.UpdateEntityRequest.entity:type_name -&gt; auth.Entity
        0,  // 3: auth.DeleteEntityRequest.type:type_name -&gt; auth.Type
        1,  // 4: auth.ListEntitiesResponse.entity:type_name -&gt; auth.Entity
        2,  // 5: auth.PassKeeper.AddEntity:input_type -&gt; auth.AddEntityRequest
        4,  // 6: auth.PassKeeper.UpdateEntity:input_type -&gt; auth.UpdateEntityRequest
        6,  // 7: auth.PassKeeper.DeleteEntity:input_type -&gt; auth.DeleteEntityRequest
        8,  // 8: auth.PassKeeper.ListEntities:input_type -&gt; auth.ListEntitiesRequest
        10, // 9: auth.PassKeeper.UploadFile:input_type -&gt; auth.UploadFileRequest
        12, // 10: auth.PassKeeper.DownloadFile:input_type -&gt; auth.DownloadFileRequest
        3,  // 11: auth.PassKeeper.AddEntity:output_type -&gt; auth.AddEntityResponse
        5,  // 12: auth.PassKeeper.UpdateEntity:output_type -&gt; auth.UpdateEntityResponse
        7,  // 13: auth.PassKeeper.DeleteEntity:output_type -&gt; auth.DeleteEntityResponse
        9,  // 14: auth.PassKeeper.ListEntities:output_type -&gt; auth.ListEntitiesResponse
        11, // 15: auth.PassKeeper.UploadFile:output_type -&gt; auth.UploadFileResponse
        13, // 16: auth.PassKeeper.DownloadFile:output_type -&gt; auth.DownloadFileResponse
        11, // [11:17] is the sub-list for method output_type
        5,  // [5:11] is the sub-list for method input_type
        5,  // [5:5] is the sub-list for extension type_name
        5,  // [5:5] is the sub-list for extension extendee
        0,  // [0:5] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_passkeeper_proto_init() }</span>
func file_passkeeper_proto_init() <span class="cov8" title="1">{
        if File_passkeeper_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_passkeeper_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Entity); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*AddEntityRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*AddEntityResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateEntityRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UpdateEntityResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteEntityRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DeleteEntityResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListEntitiesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ListEntitiesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UploadFileRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UploadFileResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DownloadFileRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_passkeeper_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DownloadFileResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_passkeeper_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   13,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_passkeeper_proto_goTypes,
                DependencyIndexes: file_passkeeper_proto_depIdxs,
                EnumInfos:         file_passkeeper_proto_enumTypes,
                MessageInfos:      file_passkeeper_proto_msgTypes,
        }.Build()
        File_passkeeper_proto = out.File
        file_passkeeper_proto_rawDesc = nil
        file_passkeeper_proto_goTypes = nil
        file_passkeeper_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v4.25.0
// source: passkeeper.proto

package passkeeperv1

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
        PassKeeper_AddEntity_FullMethodName    = "/auth.PassKeeper/AddEntity"
        PassKeeper_UpdateEntity_FullMethodName = "/auth.PassKeeper/UpdateEntity"
        PassKeeper_DeleteEntity_FullMethodName = "/auth.PassKeeper/DeleteEntity"
        PassKeeper_ListEntities_FullMethodName = "/auth.PassKeeper/ListEntities"
        PassKeeper_UploadFile_FullMethodName   = "/auth.PassKeeper/UploadFile"
        PassKeeper_DownloadFile_FullMethodName = "/auth.PassKeeper/DownloadFile"
)

// PassKeeperClient is the client API for PassKeeper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PassKeeperClient interface {
        // AddEntity adds a new entity.
        AddEntity(ctx context.Context, in *AddEntityRequest, opts ...grpc.CallOption) (*AddEntityResponse, error)
        // UpdateEntity updates the entity.
        UpdateEntity(ctx context.Context, in *UpdateEntityRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error)
        // DeleteEntity deletes the entity.
        DeleteEntity(ctx context.Context, in *DeleteEntityRequest, opts ...grpc.CallOption) (*DeleteEntityResponse, error)
        // ListEntities return all entities list.
        ListEntities(ctx context.Context, in *ListEntitiesRequest, opts ...grpc.CallOption) (*ListEntitiesResponse, error)
        // UploadFile uploads file to the server.
        UploadFile(ctx context.Context, opts ...grpc.CallOption) (PassKeeper_UploadFileClient, error)
        // DownloadFile downloads file from the server.
        DownloadFile(ctx context.Context, in *DownloadFileRequest, opts ...grpc.CallOption) (PassKeeper_DownloadFileClient, error)
}

type passKeeperClient struct {
        cc grpc.ClientConnInterface
}

func NewPassKeeperClient(cc grpc.ClientConnInterface) PassKeeperClient <span class="cov0" title="0">{
        return &amp;passKeeperClient{cc}
}</span>

func (c *passKeeperClient) AddEntity(ctx context.Context, in *AddEntityRequest, opts ...grpc.CallOption) (*AddEntityResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AddEntityResponse)
        err := c.cc.Invoke(ctx, PassKeeper_AddEntity_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *passKeeperClient) UpdateEntity(ctx context.Context, in *UpdateEntityRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateEntityResponse)
        err := c.cc.Invoke(ctx, PassKeeper_UpdateEntity_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *passKeeperClient) DeleteEntity(ctx context.Context, in *DeleteEntityRequest, opts ...grpc.CallOption) (*DeleteEntityResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteEntityResponse)
        err := c.cc.Invoke(ctx, PassKeeper_DeleteEntity_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *passKeeperClient) ListEntities(ctx context.Context, in *ListEntitiesRequest, opts ...grpc.CallOption) (*ListEntitiesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListEntitiesResponse)
        err := c.cc.Invoke(ctx, PassKeeper_ListEntities_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *passKeeperClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (PassKeeper_UploadFileClient, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;PassKeeper_ServiceDesc.Streams[0], PassKeeper_UploadFile_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;passKeeperUploadFileClient{ClientStream: stream}
        return x, nil</span>
}

type PassKeeper_UploadFileClient interface {
        Send(*UploadFileRequest) error
        CloseAndRecv() (*UploadFileResponse, error)
        grpc.ClientStream
}

type passKeeperUploadFileClient struct {
        grpc.ClientStream
}

func (x *passKeeperUploadFileClient) Send(m *UploadFileRequest) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *passKeeperUploadFileClient) CloseAndRecv() (*UploadFileResponse, error) <span class="cov0" title="0">{
        if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">m := new(UploadFileResponse)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *passKeeperClient) DownloadFile(ctx context.Context, in *DownloadFileRequest, opts ...grpc.CallOption) (PassKeeper_DownloadFileClient, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;PassKeeper_ServiceDesc.Streams[1], PassKeeper_DownloadFile_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;passKeeperDownloadFileClient{ClientStream: stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type PassKeeper_DownloadFileClient interface {
        Recv() (*DownloadFileResponse, error)
        grpc.ClientStream
}

type passKeeperDownloadFileClient struct {
        grpc.ClientStream
}

func (x *passKeeperDownloadFileClient) Recv() (*DownloadFileResponse, error) <span class="cov0" title="0">{
        m := new(DownloadFileResponse)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// PassKeeperServer is the server API for PassKeeper service.
// All implementations must embed UnimplementedPassKeeperServer
// for forward compatibility
type PassKeeperServer interface {
        // AddEntity adds a new entity.
        AddEntity(context.Context, *AddEntityRequest) (*AddEntityResponse, error)
        // UpdateEntity updates the entity.
        UpdateEntity(context.Context, *UpdateEntityRequest) (*UpdateEntityResponse, error)
        // DeleteEntity deletes the entity.
        DeleteEntity(context.Context, *DeleteEntityRequest) (*DeleteEntityResponse, error)
        // ListEntities return all entities list.
        ListEntities(context.Context, *ListEntitiesRequest) (*ListEntitiesResponse, error)
        // UploadFile uploads file to the server.
        UploadFile(PassKeeper_UploadFileServer) error
        // DownloadFile downloads file from the server.
        DownloadFile(*DownloadFileRequest, PassKeeper_DownloadFileServer) error
        mustEmbedUnimplementedPassKeeperServer()
}

// UnimplementedPassKeeperServer must be embedded to have forward compatible implementations.
type UnimplementedPassKeeperServer struct {
}

func (UnimplementedPassKeeperServer) AddEntity(context.Context, *AddEntityRequest) (*AddEntityResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddEntity not implemented")
}</span>
func (UnimplementedPassKeeperServer) UpdateEntity(context.Context, *UpdateEntityRequest) (*UpdateEntityResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateEntity not implemented")
}</span>
func (UnimplementedPassKeeperServer) DeleteEntity(context.Context, *DeleteEntityRequest) (*DeleteEntityResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteEntity not implemented")
}</span>
func (UnimplementedPassKeeperServer) ListEntities(context.Context, *ListEntitiesRequest) (*ListEntitiesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListEntities not implemented")
}</span>
func (UnimplementedPassKeeperServer) UploadFile(PassKeeper_UploadFileServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}</span>
func (UnimplementedPassKeeperServer) DownloadFile(*DownloadFileRequest, PassKeeper_DownloadFileServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method DownloadFile not implemented")
}</span>
func (UnimplementedPassKeeperServer) mustEmbedUnimplementedPassKeeperServer() {<span class="cov0" title="0">}</span>

// UnsafePassKeeperServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PassKeeperServer will
// result in compilation errors.
type UnsafePassKeeperServer interface {
        mustEmbedUnimplementedPassKeeperServer()
}

func RegisterPassKeeperServer(s grpc.ServiceRegistrar, srv PassKeeperServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;PassKeeper_ServiceDesc, srv)
}</span>

func _PassKeeper_AddEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddEntityRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PassKeeperServer).AddEntity(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PassKeeper_AddEntity_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PassKeeperServer).AddEntity(ctx, req.(*AddEntityRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PassKeeper_UpdateEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateEntityRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PassKeeperServer).UpdateEntity(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PassKeeper_UpdateEntity_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PassKeeperServer).UpdateEntity(ctx, req.(*UpdateEntityRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PassKeeper_DeleteEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteEntityRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PassKeeperServer).DeleteEntity(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PassKeeper_DeleteEntity_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PassKeeperServer).DeleteEntity(ctx, req.(*DeleteEntityRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PassKeeper_ListEntities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListEntitiesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PassKeeperServer).ListEntities(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PassKeeper_ListEntities_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PassKeeperServer).ListEntities(ctx, req.(*ListEntitiesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PassKeeper_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(PassKeeperServer).UploadFile(&amp;passKeeperUploadFileServer{ServerStream: stream})
}</span>

type PassKeeper_UploadFileServer interface {
        SendAndClose(*UploadFileResponse) error
        Recv() (*UploadFileRequest, error)
        grpc.ServerStream
}

type passKeeperUploadFileServer struct {
        grpc.ServerStream
}

func (x *passKeeperUploadFileServer) SendAndClose(m *UploadFileResponse) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *passKeeperUploadFileServer) Recv() (*UploadFileRequest, error) <span class="cov0" title="0">{
        m := new(UploadFileRequest)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _PassKeeper_DownloadFile_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(DownloadFileRequest)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(PassKeeperServer).DownloadFile(m, &amp;passKeeperDownloadFileServer{ServerStream: stream})</span>
}

type PassKeeper_DownloadFileServer interface {
        Send(*DownloadFileResponse) error
        grpc.ServerStream
}

type passKeeperDownloadFileServer struct {
        grpc.ServerStream
}

func (x *passKeeperDownloadFileServer) Send(m *DownloadFileResponse) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

// PassKeeper_ServiceDesc is the grpc.ServiceDesc for PassKeeper service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PassKeeper_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "auth.PassKeeper",
        HandlerType: (*PassKeeperServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "AddEntity",
                        Handler:    _PassKeeper_AddEntity_Handler,
                },
                {
                        MethodName: "UpdateEntity",
                        Handler:    _PassKeeper_UpdateEntity_Handler,
                },
                {
                        MethodName: "DeleteEntity",
                        Handler:    _PassKeeper_DeleteEntity_Handler,
                },
                {
                        MethodName: "ListEntities",
                        Handler:    _PassKeeper_ListEntities_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "UploadFile",
                        Handler:       _PassKeeper_UploadFile_Handler,
                        ClientStreams: true,
                },
                {
                        StreamName:    "DownloadFile",
                        Handler:       _PassKeeper_DownloadFile_Handler,
                        ServerStreams: true,
                },
        },
        Metadata: "passkeeper.proto",
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package auth provides an API to create and log in users.
package auth

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "time"

        "golang.org/x/crypto/bcrypt"

        "github.com/vindosVP/go-pass/internal/jwt"
        "github.com/vindosVP/go-pass/internal/models"
        "github.com/vindosVP/go-pass/internal/storage"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

// UserStorage is a user storage interface.
//
//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=UserStorage
type UserStorage interface {
        CreateUser(ctx context.Context, email string, passHash []byte) (*models.User, error)
        UserByEmail(ctx context.Context, email string) (*models.User, error)
}

var (
        // ErrUserAlreadyExists - user already exists error.
        ErrUserAlreadyExists = errors.New("user already exists")

        // ErrInvalidCredentials - invalid credentials error.
        ErrInvalidCredentials = errors.New("invalid credentials")
)

// Auth consists the authentication fields.
type Auth struct {
        userStorage UserStorage
        tokenTTL    time.Duration
        secret      string
}

// New creates the Auth instance.
func New(us UserStorage, tokenTTL time.Duration, secret string) *Auth <span class="cov8" title="1">{
        return &amp;Auth{userStorage: us, tokenTTL: tokenTTL, secret: secret}
}</span>

// CreateUser creates a new user with provided email and password.
func (a *Auth) CreateUser(ctx context.Context, email string, pass string) (*models.User, error) <span class="cov8" title="1">{

        lg := sl.Log.With(slog.String("email", email))
        lg.Info("creating user")

        passHash, err := bcrypt.GenerateFromPassword([]byte(pass), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                lg.Error("failed to generate password hash", sl.Err(err))
                return nil, fmt.Errorf("failed to generate password hash: %w", err)
        }</span>
        <span class="cov8" title="1">user, err := a.userStorage.CreateUser(ctx, email, passHash)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, storage.ErrUserAlreadyExists) </span><span class="cov8" title="1">{
                        lg.Info("user already exists")
                        return nil, ErrUserAlreadyExists
                }</span>
                <span class="cov8" title="1">lg.Error("failed to create user", sl.Err(err))
                return nil, fmt.Errorf("failed to create user: %w", err)</span>
        }

        <span class="cov8" title="1">lg.Info("user created")
        return user, nil</span>
}

// Login logs in user with provided email and password.
func (a *Auth) Login(ctx context.Context, email string, pass string) (string, error) <span class="cov8" title="1">{

        lg := sl.Log.With(slog.String("email", email))
        lg.Info("logging in user")

        user, err := a.userStorage.UserByEmail(ctx, email)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, storage.ErrUserNotExist) </span><span class="cov8" title="1">{
                        lg.Info("invalid credentials")
                        return "", ErrInvalidCredentials
                }</span>
                <span class="cov0" title="0">lg.Error("failed to get user", sl.Err(err))
                return "", fmt.Errorf("failed to get user: %w", err)</span>
        }
        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword(user.PassHash, []byte(pass))
        if err != nil </span><span class="cov8" title="1">{
                lg.Info("invalid credentials")
                return "", ErrInvalidCredentials
        }</span>
        <span class="cov8" title="1">token, err := jwt.NewToken(user, a.tokenTTL, a.secret)
        if err != nil </span><span class="cov0" title="0">{
                lg.Error("failed to create token", sl.Err(err))
                return "", fmt.Errorf("failed to create token: %w", err)
        }</span>

        <span class="cov8" title="1">lg.Info("user logged in")
        return token, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        models "github.com/vindosVP/go-pass/internal/models"
)

// UserStorage is an autogenerated mock type for the UserStorage type
type UserStorage struct {
        mock.Mock
}

// CreateUser provides a mock function with given fields: ctx, email, passHash
func (_m *UserStorage) CreateUser(ctx context.Context, email string, passHash []byte) (*models.User, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, email, passHash)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateUser")</span>
        }

        <span class="cov8" title="1">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string, []byte) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email, passHash)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string, []byte) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, passHash)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string, []byte) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, passHash)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UserByEmail provides a mock function with given fields: ctx, email
func (_m *UserStorage) UserByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, email)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UserByEmail")</span>
        }

        <span class="cov8" title="1">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, email)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewUserStorage creates a new instance of UserStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUserStorage(t interface {
        mock.TestingT
        Cleanup(func())
}) *UserStorage <span class="cov8" title="1">{
        mock := &amp;UserStorage{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        models "github.com/vindosVP/go-pass/internal/models"
)

// CardStorage is an autogenerated mock type for the CardStorage type
type CardStorage struct {
        mock.Mock
}

// AddCard provides a mock function with given fields: ctx, card
func (_m *CardStorage) AddCard(ctx context.Context, card *models.Card) (int, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, card)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AddCard")</span>
        }

        <span class="cov8" title="1">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Card) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, card)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *models.Card) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, card)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *models.Card) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, card)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// DeleteCard provides a mock function with given fields: ctx, id, ownerID
func (_m *CardStorage) DeleteCard(ctx context.Context, id int, ownerID int) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, id, ownerID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteCard")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id, ownerID)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// GetCards provides a mock function with given fields: ctx, ownerID
func (_m *CardStorage) GetCards(ctx context.Context, ownerID int) ([]*models.Card, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, ownerID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetCards")</span>
        }

        <span class="cov8" title="1">var r0 []*models.Card
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]*models.Card, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, ownerID)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int) []*models.Card); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, ownerID)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]*models.Card)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, ownerID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UpdateCard provides a mock function with given fields: ctx, card
func (_m *CardStorage) UpdateCard(ctx context.Context, card *models.Card) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, card)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateCard")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Card) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, card)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// NewCardStorage creates a new instance of CardStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCardStorage(t interface {
        mock.TestingT
        Cleanup(func())
}) *CardStorage <span class="cov8" title="1">{
        mock := &amp;CardStorage{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        models "github.com/vindosVP/go-pass/internal/models"
)

// FileStorage is an autogenerated mock type for the FileStorage type
type FileStorage struct {
        mock.Mock
}

// AddFile provides a mock function with given fields: ctx, f
func (_m *FileStorage) AddFile(ctx context.Context, f *models.File) (int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, f)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AddFile")</span>
        }

        <span class="cov0" title="0">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.File) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, f)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(context.Context, *models.File) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, f)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(context.Context, *models.File) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, f)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// DeleteFile provides a mock function with given fields: ctx, id, ownerID
func (_m *FileStorage) DeleteFile(ctx context.Context, id int, ownerID int) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, id, ownerID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteFile")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id, ownerID)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// GetFile provides a mock function with given fields: ctx, id, ownerID
func (_m *FileStorage) GetFile(ctx context.Context, id int, ownerID int) (*models.File, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, id, ownerID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetFile")</span>
        }

        <span class="cov8" title="1">var r0 *models.File
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int, int) (*models.File, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, id, ownerID)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int, int) *models.File); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id, ownerID)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(*models.File)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id, ownerID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetFiles provides a mock function with given fields: ctx, ownerID
func (_m *FileStorage) GetFiles(ctx context.Context, ownerID int) ([]*models.File, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, ownerID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetFiles")</span>
        }

        <span class="cov8" title="1">var r0 []*models.File
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]*models.File, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, ownerID)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int) []*models.File); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, ownerID)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]*models.File)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, ownerID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MarkFileAsUploaded provides a mock function with given fields: ctx, id, ownerID
func (_m *FileStorage) MarkFileAsUploaded(ctx context.Context, id int, ownerID int) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, id, ownerID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for MarkFileAsUploaded")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id, ownerID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewFileStorage creates a new instance of FileStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFileStorage(t interface {
        mock.TestingT
        Cleanup(func())
}) *FileStorage <span class="cov8" title="1">{
        mock := &amp;FileStorage{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        models "github.com/vindosVP/go-pass/internal/models"
)

// PasswordStorage is an autogenerated mock type for the PasswordStorage type
type PasswordStorage struct {
        mock.Mock
}

// AddPassword provides a mock function with given fields: ctx, pwd
func (_m *PasswordStorage) AddPassword(ctx context.Context, pwd *models.Password) (int, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, pwd)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AddPassword")</span>
        }

        <span class="cov8" title="1">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Password) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, pwd)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *models.Password) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, pwd)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *models.Password) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, pwd)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// DeletePassword provides a mock function with given fields: ctx, id, ownerID
func (_m *PasswordStorage) DeletePassword(ctx context.Context, id int, ownerID int) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, id, ownerID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeletePassword")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id, ownerID)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// GetPasswords provides a mock function with given fields: ctx, ownerID
func (_m *PasswordStorage) GetPasswords(ctx context.Context, ownerID int) ([]*models.Password, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, ownerID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetPasswords")</span>
        }

        <span class="cov8" title="1">var r0 []*models.Password
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]*models.Password, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, ownerID)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int) []*models.Password); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, ownerID)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]*models.Password)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, ownerID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UpdatePassword provides a mock function with given fields: ctx, pwd
func (_m *PasswordStorage) UpdatePassword(ctx context.Context, pwd *models.Password) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, pwd)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdatePassword")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Password) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, pwd)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// NewPasswordStorage creates a new instance of PasswordStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPasswordStorage(t interface {
        mock.TestingT
        Cleanup(func())
}) *PasswordStorage <span class="cov8" title="1">{
        mock := &amp;PasswordStorage{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        models "github.com/vindosVP/go-pass/internal/models"
)

// TextStorage is an autogenerated mock type for the TextStorage type
type TextStorage struct {
        mock.Mock
}

// AddText provides a mock function with given fields: ctx, t
func (_m *TextStorage) AddText(ctx context.Context, t *models.Text) (int, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, t)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AddText")</span>
        }

        <span class="cov8" title="1">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Text) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, t)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, *models.Text) int); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, t)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, *models.Text) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, t)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// DeleteText provides a mock function with given fields: ctx, id, ownerID
func (_m *TextStorage) DeleteText(ctx context.Context, id int, ownerID int) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, id, ownerID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteText")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id, ownerID)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// GetTexts provides a mock function with given fields: ctx, ownerID
func (_m *TextStorage) GetTexts(ctx context.Context, ownerID int) ([]*models.Text, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, ownerID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetTexts")</span>
        }

        <span class="cov8" title="1">var r0 []*models.Text
        var r1 error
        if rf, ok := ret.Get(0).(func(context.Context, int) ([]*models.Text, error)); ok </span><span class="cov0" title="0">{
                return rf(ctx, ownerID)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(context.Context, int) []*models.Text); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, ownerID)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]*models.Text)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, ownerID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// UpdateText provides a mock function with given fields: ctx, t
func (_m *TextStorage) UpdateText(ctx context.Context, t *models.Text) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, t)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateText")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *models.Text) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, t)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// NewTextStorage creates a new instance of TextStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTextStorage(t interface {
        mock.TestingT
        Cleanup(func())
}) *TextStorage <span class="cov8" title="1">{
        mock := &amp;TextStorage{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package passkeeper

import (
        "context"
        "errors"
        "fmt"
        "io"
        "log/slog"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        "github.com/vindosVP/go-pass/internal/filemanager"
        "github.com/vindosVP/go-pass/internal/models"
        passkeeperv1 "github.com/vindosVP/go-pass/internal/proto/passkeeper"
        "github.com/vindosVP/go-pass/internal/storage"
        "github.com/vindosVP/go-pass/pkg/grpcmd"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

var (

        // ErrUnknownEntity - error if entity`s type is unknown
        ErrUnknownEntity = errors.New("unknown entity")

        // ErrUnableToUpdateFile - error if tried to update file, to update delete file and add another one
        ErrUnableToUpdateFile = errors.New("unable to update file")

        // ErrUnableToSaveFile - error if tried to save file, to save file, use SaveFile method
        ErrUnableToSaveFile = errors.New("unable to save file")
)

// PasswordStorage is a password storage API
//
//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=PasswordStorage
type PasswordStorage interface {
        AddPassword(ctx context.Context, pwd *models.Password) (int, error)
        UpdatePassword(ctx context.Context, pwd *models.Password) error
        DeletePassword(ctx context.Context, id int, ownerID int) error
        GetPasswords(ctx context.Context, ownerID int) ([]*models.Password, error)
}

// CardStorage is a card storage API
//
//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=CardStorage
type CardStorage interface {
        AddCard(ctx context.Context, card *models.Card) (int, error)
        UpdateCard(ctx context.Context, card *models.Card) error
        DeleteCard(ctx context.Context, id int, ownerID int) error
        GetCards(ctx context.Context, ownerID int) ([]*models.Card, error)
}

// TextStorage is a text storage API
//
//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=TextStorage
type TextStorage interface {
        AddText(ctx context.Context, t *models.Text) (int, error)
        UpdateText(ctx context.Context, t *models.Text) error
        DeleteText(ctx context.Context, id int, ownerID int) error
        GetTexts(ctx context.Context, ownerID int) ([]*models.Text, error)
}

// FileStorage is a file storage API
//
//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=FileStorage
type FileStorage interface {
        GetFiles(ctx context.Context, ownerID int) ([]*models.File, error)
        GetFile(ctx context.Context, id int, ownerID int) (*models.File, error)
        DeleteFile(ctx context.Context, id int, ownerID int) error
        AddFile(ctx context.Context, f *models.File) (int, error)
        MarkFileAsUploaded(ctx context.Context, id int, ownerID int) error
}

type Keeper struct {
        ps    PasswordStorage
        cs    CardStorage
        ts    TextStorage
        fs    FileStorage
        fPath string
}

const chunkSize = 4 * 1024

// List returns all user`s entities.
func (k *Keeper) List(ctx context.Context, ownerID int) ([]*models.Entity, error) <span class="cov8" title="1">{

        sl.Log.Info("getting list of entities")

        res := make([]*models.Entity, 0)

        pwds, err := k.ps.GetPasswords(ctx, ownerID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, pwd := range pwds </span><span class="cov0" title="0">{
                res = append(res, pwd.ToEntity())
        }</span>

        <span class="cov8" title="1">cards, err := k.cs.GetCards(ctx, ownerID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, card := range cards </span><span class="cov0" title="0">{
                res = append(res, card.ToEntity())
        }</span>

        <span class="cov8" title="1">texts, err := k.ts.GetTexts(ctx, ownerID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, text := range texts </span><span class="cov0" title="0">{
                res = append(res, text.ToEntity())
        }</span>

        <span class="cov8" title="1">files, err := k.fs.GetFiles(ctx, ownerID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, file := range files </span><span class="cov0" title="0">{
                res = append(res, file.ToEntity())
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}

// Save saves the entity (password, card or text).
func (k *Keeper) Save(ctx context.Context, e *models.Entity) (int, error) <span class="cov8" title="1">{
        switch e.Type </span>{
        case models.TypePassword:<span class="cov8" title="1">
                sl.Log.Info("adding new password")
                return k.ps.AddPassword(ctx, e.ToPassword())</span>
        case models.TypeCard:<span class="cov8" title="1">
                sl.Log.Info("adding new card")
                return k.cs.AddCard(ctx, e.ToCard())</span>
        case models.TypeText:<span class="cov8" title="1">
                sl.Log.Info("adding new text")
                return k.ts.AddText(ctx, e.ToText())</span>
        case models.TypeFile:<span class="cov8" title="1">
                sl.Log.Error("unable to save file")
                return 0, ErrUnableToSaveFile</span>
        }
        <span class="cov8" title="1">sl.Log.Error("unknown entity type", slog.String("type", string(e.Type)))
        return 0, ErrUnknownEntity</span>
}

// Delete deletes the entity.
func (k *Keeper) Delete(ctx context.Context, id int, ownerID int, t models.EntityType) error <span class="cov8" title="1">{
        switch t </span>{
        case models.TypePassword:<span class="cov8" title="1">
                sl.Log.Info("deleting password", slog.Int("id", id))
                return k.ps.DeletePassword(ctx, id, ownerID)</span>
        case models.TypeCard:<span class="cov8" title="1">
                sl.Log.Info("deleting card", slog.Int("id", id))
                return k.cs.DeleteCard(ctx, id, ownerID)</span>
        case models.TypeText:<span class="cov8" title="1">
                sl.Log.Info("deleting text", slog.Int("id", id))
                return k.ts.DeleteText(ctx, id, ownerID)</span>
        case models.TypeFile:<span class="cov8" title="1">
                sl.Log.Info("deleting text", slog.Int("id", id))
                file, err := k.fs.GetFile(ctx, id, ownerID)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">deleter := filemanager.NewFileDeleter()
                filename := fmt.Sprintf("%d_%s", file.ID, file.FileName)
                deleter.SetFile(filename, k.fPath)
                err = deleter.Delete()
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return k.fs.DeleteFile(ctx, id, ownerID)</span>
        }
        <span class="cov0" title="0">sl.Log.Error("unknown entity type", slog.String("type", string(t)))
        return ErrUnknownEntity</span>
}

// Update updates the entity (password, card or text).
func (k *Keeper) Update(ctx context.Context, e *models.Entity) error <span class="cov8" title="1">{
        switch e.Type </span>{
        case models.TypePassword:<span class="cov8" title="1">
                sl.Log.Info("updating password", slog.Int("id", e.ID))
                return k.ps.UpdatePassword(ctx, e.ToPassword())</span>
        case models.TypeCard:<span class="cov8" title="1">
                sl.Log.Info("updating card", slog.Int("id", e.ID))
                return k.cs.UpdateCard(ctx, e.ToCard())</span>
        case models.TypeText:<span class="cov8" title="1">
                sl.Log.Info("updating text", slog.Int("id", e.ID))
                return k.ts.UpdateText(ctx, e.ToText())</span>
        case models.TypeFile:<span class="cov8" title="1">
                sl.Log.Error("unable to update file")
                return ErrUnableToUpdateFile</span>
        }
        <span class="cov0" title="0">sl.Log.Error("unknown entity type", slog.String("type", string(e.Type)))
        return ErrUnknownEntity</span>
}

// SaveFile saves the file.
func (k *Keeper) SaveFile(str passkeeperv1.PassKeeper_UploadFileServer) error <span class="cov0" title="0">{

        lg := sl.Log
        lg.Info("handling upload file request")

        savedToDB := false
        var fileId int
        var ownerID int

        f := filemanager.NewFileSaver()
        defer f.Close()

        for </span><span class="cov0" title="0">{
                req, err := str.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        lg.Error("failed to save file", sl.Err(err))
                        return status.Errorf(codes.Internal, "failed to upload file")
                }</span>
                <span class="cov0" title="0">if !savedToDB </span><span class="cov0" title="0">{
                        uid, err := grpcmd.ExtractUID(str.Context())
                        if err != nil </span><span class="cov0" title="0">{
                                return status.Errorf(codes.InvalidArgument, "failed to extract uid")
                        }</span>
                        <span class="cov0" title="0">ownerID = uid
                        file := &amp;models.File{
                                OwnerID:  uid,
                                FileName: req.Filename,
                                Metadata: req.Metadata,
                        }
                        id, err := k.fs.AddFile(str.Context(), file)
                        if err != nil </span><span class="cov0" title="0">{
                                lg.Error("failed to save file", sl.Err(err))
                                return status.Errorf(codes.Internal, "failed to save file")
                        }</span>
                        <span class="cov0" title="0">fileId = id
                        savedToDB = true</span>
                }
                <span class="cov0" title="0">if !f.IsFileSet() </span><span class="cov0" title="0">{
                        filename := fmt.Sprintf("%d_%s", fileId, req.GetFilename())
                        err := f.SetFile(filename, k.fPath)
                        if err != nil </span><span class="cov0" title="0">{
                                lg.Error("failed to save file", sl.Err(err))
                                return status.Errorf(codes.Internal, "failed to save file")
                        }</span>
                }

                <span class="cov0" title="0">ch := req.GetChunk()
                if err = f.Write(ch); err != nil </span><span class="cov0" title="0">{
                        lg.Error("failed to save file", sl.Err(err))
                        return status.Errorf(codes.Internal, "failed to upload file")
                }</span>
        }

        <span class="cov0" title="0">err := k.fs.MarkFileAsUploaded(str.Context(), fileId, ownerID)
        if err != nil </span><span class="cov0" title="0">{
                lg.Error("failed to save file", sl.Err(err))
                return status.Errorf(codes.Internal, "failed to upload file")
        }</span>

        <span class="cov0" title="0">err = str.SendAndClose(&amp;passkeeperv1.UploadFileResponse{Id: int64(fileId)})
        if err != nil </span><span class="cov0" title="0">{
                lg.Error("failed to save file", sl.Err(err))
                return status.Errorf(codes.Internal, "failed to save file")
        }</span>

        <span class="cov0" title="0">lg.Info("saved file")
        return nil</span>

}

// DownloadFile returns the file to download.
func (k *Keeper) DownloadFile(id int, ownerID int, str passkeeperv1.PassKeeper_DownloadFileServer) error <span class="cov0" title="0">{

        lg := sl.Log
        lg.Info("handling download file request")

        file, err := k.fs.GetFile(str.Context(), id, ownerID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, storage.ErrFileNotExist) </span><span class="cov0" title="0">{
                        lg.Info("file not found")
                        return status.Errorf(codes.NotFound, "file not found")
                }</span>
                <span class="cov0" title="0">lg.Error("failed to download file", sl.Err(err))
                return status.Errorf(codes.Internal, "failed to download file")</span>
        }

        <span class="cov0" title="0">filename := fmt.Sprintf("%d_%s", file.ID, file.FileName)
        fileReader := filemanager.NewFileReader(chunkSize)
        err = fileReader.SetFile(filename, k.fPath)
        if err != nil </span><span class="cov0" title="0">{
                lg.Error("failed to download file", sl.Err(err))
                return status.Errorf(codes.Internal, "failed to download file")
        }</span>
        <span class="cov0" title="0">defer fileReader.Close()
        for fileReader.Next() </span><span class="cov0" title="0">{
                resp := &amp;passkeeperv1.DownloadFileResponse{
                        Filename: file.FileName,
                        Chunk:    fileReader.Data(),
                }
                err = str.Send(resp)
                if err != nil </span><span class="cov0" title="0">{
                        lg.Error("failed to download file", sl.Err(err))
                        return status.Errorf(codes.Internal, "failed to download file")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// New creates a new Keeper instance
func New(ps PasswordStorage, cs CardStorage, ts TextStorage, fs FileStorage, fPath string) *Keeper <span class="cov8" title="1">{
        return &amp;Keeper{ps: ps, cs: cs, ts: ts, fs: fs, fPath: fPath}
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package postgres is a package for postgres storage
package postgres

import (
        "context"
        "errors"
        "fmt"
        "syscall"
        "time"

        "github.com/avast/retry-go/v4"
        "github.com/jackc/pgerrcode"
        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/jackc/pgx/v5/pgxpool"

        "github.com/vindosVP/go-pass/internal/models"
        "github.com/vindosVP/go-pass/internal/storage"
        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

var retryDelays = map[uint]time.Duration{
        0: 1 * time.Second,
        1: 3 * time.Second,
        2: 5 * time.Second,
}

// Storage consists the database
type Storage struct {
        db *pgxpool.Pool
}

// New creates the Storage instance
func New(db *pgxpool.Pool) *Storage <span class="cov8" title="1">{
        return &amp;Storage{db: db}
}</span>

// CreateUser creates user with provided email and password hash
func (s *Storage) CreateUser(ctx context.Context, email string, passHash []byte) (*models.User, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() (*models.User, error) </span><span class="cov8" title="1">{
                query := "insert into users (email, hashed_password, created_at) values ($1, $2, $3) returning id, email, hashed_password, created_at"
                row := s.db.QueryRow(ctx, query, email, passHash, time.Now())
                user := &amp;models.User{}
                if err := row.Scan(&amp;user.ID, &amp;user.Email, &amp;user.PassHash, &amp;user.CreatedAt); err != nil </span><span class="cov8" title="1">{
                        if pgErrCode(err) == pgerrcode.UniqueViolation </span><span class="cov8" title="1">{
                                return nil, storage.ErrUserAlreadyExists
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">return user, nil</span>
        }, retryOpts()...)
}

// UserByEmail finds a user by provided email
func (s *Storage) UserByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() (*models.User, error) </span><span class="cov8" title="1">{
                query := "select id, email, hashed_password, created_at from users where email = $1"
                row := s.db.QueryRow(ctx, query, email)
                user := &amp;models.User{}
                if err := row.Scan(&amp;user.ID, &amp;user.Email, &amp;user.PassHash, &amp;user.CreatedAt); err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                                return nil, storage.ErrUserNotExist
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">return user, nil</span>
        }, retryOpts()...)
}

// AddPassword adds a new login-password pair
func (s *Storage) AddPassword(ctx context.Context, pwd *models.Password) (int, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() (int, error) </span><span class="cov8" title="1">{
                query := `insert into passwords (owner_id, login, password, metadata, created_at) 
                                        values ($1, $2, $3, $4, $5) returning id`
                row := s.db.QueryRow(ctx, query, pwd.OwnerID, pwd.Login, pwd.Password, pwd.Metadata, time.Now())
                var id int
                err := row.Scan(&amp;id)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">return id, nil</span>
        }, retryOpts()...)
}

// AddCard adds a new bank card
func (s *Storage) AddCard(ctx context.Context, card *models.Card) (int, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() (int, error) </span><span class="cov8" title="1">{
                query := `insert into cards (owner_id, number, cvc, owner, date, metadata, created_at) 
                                        values ($1, $2, $3, $4, $5, $6, $7) returning id`
                row := s.db.QueryRow(ctx, query, card.OwnerID, card.Number, card.CVC, card.Owner, card.Date, card.Metadata, time.Now())
                var id int
                err := row.Scan(&amp;id)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">return id, nil</span>
        }, retryOpts()...)
}

// AddText adds a new text
func (s *Storage) AddText(ctx context.Context, t *models.Text) (int, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() (int, error) </span><span class="cov8" title="1">{
                query := `insert into texts (owner_id, text, metadata, created_at) 
                                        values ($1, $2, $3, $4) returning id`
                row := s.db.QueryRow(ctx, query, t.OwnerID, t.Text, t.Metadata, time.Now())
                var id int
                err := row.Scan(&amp;id)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">return id, nil</span>
        }, retryOpts()...)
}

// AddFile adds a new file
func (s *Storage) AddFile(ctx context.Context, f *models.File) (int, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() (int, error) </span><span class="cov8" title="1">{
                query := `insert into files (owner_id, filename, metadata, created_at) 
                                        values ($1, $2, $3, $4) returning id`
                row := s.db.QueryRow(ctx, query, f.OwnerID, f.FileName, f.Metadata, time.Now())
                var id int
                err := row.Scan(&amp;id)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">return id, nil</span>
        }, retryOpts()...)
}

// UpdatePassword updates the password
func (s *Storage) UpdatePassword(ctx context.Context, pwd *models.Password) error <span class="cov8" title="1">{
        return retry.Do(func() error </span><span class="cov8" title="1">{
                query := `update 
                                    passwords 
                                  set 
                                        login=$1, 
                                        password=$2, 
                                        metadata=$3
                                  where
                                    id = $4 and owner_id = $5`
                _, err := s.db.Exec(ctx, query, pwd.Login, pwd.Password, pwd.Metadata, pwd.ID, pwd.OwnerID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, retryOpts()...)
}

// UpdateCard updates the bank card
func (s *Storage) UpdateCard(ctx context.Context, card *models.Card) error <span class="cov8" title="1">{
        return retry.Do(func() error </span><span class="cov8" title="1">{
                query := `update 
                                    cards 
                                  set 
                                        number=$1, 
                                        cvc=$2, 
                                        owner=$3,
                                        date=$4,
                                        metadata=$5
                                  where
                                    id = $6 and owner_id = $7`
                _, err := s.db.Exec(ctx, query, card.Number, card.CVC, card.Owner, card.Date, card.Metadata, card.ID, card.OwnerID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, retryOpts()...)
}

// UpdateText updates the text
func (s *Storage) UpdateText(ctx context.Context, t *models.Text) error <span class="cov8" title="1">{
        return retry.Do(func() error </span><span class="cov8" title="1">{
                query := `update 
                                    texts 
                                  set 
                                        text=$1, 
                                        metadata=$2
                                  where
                                    id = $3 and owner_id = $4`
                _, err := s.db.Exec(ctx, query, t.Text, t.Metadata, t.ID, t.OwnerID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, retryOpts()...)
}

// DeletePassword deletes the password
func (s *Storage) DeletePassword(ctx context.Context, id int, ownerID int) error <span class="cov8" title="1">{
        return retry.Do(func() error </span><span class="cov8" title="1">{
                query := `delete from  
                                    passwords 
                                  where
                                    id = $1 and owner_id = $2`
                _, err := s.db.Exec(ctx, query, id, ownerID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, retryOpts()...)
}

// DeleteCard deletes the bank card
func (s *Storage) DeleteCard(ctx context.Context, id int, ownerID int) error <span class="cov8" title="1">{
        return retry.Do(func() error </span><span class="cov8" title="1">{
                query := `delete from  
                                    cards 
                                  where
                                    id = $1 and owner_id = $2`
                _, err := s.db.Exec(ctx, query, id, ownerID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, retryOpts()...)
}

// DeleteText deletes the text
func (s *Storage) DeleteText(ctx context.Context, id int, ownerID int) error <span class="cov8" title="1">{
        return retry.Do(func() error </span><span class="cov8" title="1">{
                query := `delete from  
                                    texts 
                                  where
                                    id = $1 and owner_id = $2`
                _, err := s.db.Exec(ctx, query, id, ownerID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, retryOpts()...)
}

// DeleteFile deletes the file
func (s *Storage) DeleteFile(ctx context.Context, id int, ownerID int) error <span class="cov8" title="1">{
        return retry.Do(func() error </span><span class="cov8" title="1">{
                query := `delete from  
                                    files 
                                  where
                                    id = $1 and owner_id = $2`
                _, err := s.db.Exec(ctx, query, id, ownerID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, retryOpts()...)
}

// GetPasswords returns all passwords
func (s *Storage) GetPasswords(ctx context.Context, ownerID int) ([]*models.Password, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() ([]*models.Password, error) </span><span class="cov8" title="1">{
                query := `select
                                    id, owner_id, login, password, metadata, created_at
                              from  
                                    passwords 
                                  where
                                    owner_id = $1`
                rows, err := s.db.Query(ctx, query, ownerID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                pwds := make([]*models.Password, 0)
                for rows.Next() </span><span class="cov8" title="1">{
                        pwd := &amp;models.Password{}
                        err = rows.Scan(&amp;pwd.ID, &amp;pwd.OwnerID, &amp;pwd.Login, &amp;pwd.Password, &amp;pwd.Metadata, &amp;pwd.CreatedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">pwds = append(pwds, pwd)</span>
                }
                <span class="cov8" title="1">return pwds, nil</span>
        }, retryOpts()...)
}

// GetCards returns all bank cards
func (s *Storage) GetCards(ctx context.Context, ownerID int) ([]*models.Card, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() ([]*models.Card, error) </span><span class="cov8" title="1">{
                query := `select
                                    id, owner_id, number, cvc, owner, date, metadata, created_at
                              from  
                                    cards 
                                  where
                                    owner_id = $1`
                rows, err := s.db.Query(ctx, query, ownerID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                cards := make([]*models.Card, 0)
                for rows.Next() </span><span class="cov8" title="1">{
                        c := &amp;models.Card{}
                        err = rows.Scan(&amp;c.ID, &amp;c.OwnerID, &amp;c.Number, &amp;c.CVC, &amp;c.Owner, &amp;c.Date, &amp;c.Metadata, &amp;c.CreatedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">cards = append(cards, c)</span>
                }
                <span class="cov8" title="1">return cards, nil</span>
        }, retryOpts()...)
}

// GetTexts returns all texts
func (s *Storage) GetTexts(ctx context.Context, ownerID int) ([]*models.Text, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() ([]*models.Text, error) </span><span class="cov8" title="1">{
                query := `select
                                    id, owner_id, text, metadata, created_at
                              from  
                                    texts 
                                  where
                                    owner_id = $1`
                rows, err := s.db.Query(ctx, query, ownerID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                texts := make([]*models.Text, 0)
                for rows.Next() </span><span class="cov8" title="1">{
                        t := &amp;models.Text{}
                        err = rows.Scan(&amp;t.ID, &amp;t.OwnerID, &amp;t.Text, &amp;t.Metadata, &amp;t.CreatedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">texts = append(texts, t)</span>
                }
                <span class="cov8" title="1">return texts, nil</span>
        }, retryOpts()...)
}

// GetFiles returns all files
func (s *Storage) GetFiles(ctx context.Context, ownerID int) ([]*models.File, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() ([]*models.File, error) </span><span class="cov8" title="1">{
                query := `select
                                    id, owner_id, filename, metadata, created_at
                              from  
                                    files 
                                  where
                                    owner_id = $1 and uploaded`
                rows, err := s.db.Query(ctx, query, ownerID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                files := make([]*models.File, 0)
                for rows.Next() </span><span class="cov8" title="1">{
                        f := &amp;models.File{}
                        err = rows.Scan(&amp;f.ID, &amp;f.OwnerID, &amp;f.FileName, &amp;f.Metadata, &amp;f.CreatedAt)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">files = append(files, f)</span>
                }
                <span class="cov8" title="1">return files, nil</span>
        }, retryOpts()...)
}

// GetFile returns a file.
func (s *Storage) GetFile(ctx context.Context, id int, ownerID int) (*models.File, error) <span class="cov8" title="1">{
        return retry.DoWithData(func() (*models.File, error) </span><span class="cov8" title="1">{
                query := `select
                                    id, owner_id, filename, metadata, created_at
                              from  
                                    files 
                                  where
                                    id = $1 and owner_id = $2`
                row := s.db.QueryRow(ctx, query, id, ownerID)
                file := &amp;models.File{}
                err := row.Scan(&amp;file.ID, &amp;file.OwnerID, &amp;file.FileName, &amp;file.Metadata, &amp;file.CreatedAt)
                if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov8" title="1">{
                                return nil, storage.ErrFileNotExist
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">return file, nil</span>
        }, retryOpts()...)
}

// MarkFileAsUploaded marks the file as uploaded.
func (s *Storage) MarkFileAsUploaded(ctx context.Context, id int, ownerID int) error <span class="cov8" title="1">{
        return retry.Do(func() error </span><span class="cov8" title="1">{
                query := `update files set 
                                    uploaded=true 
                                  where
                                    id = $1 and owner_id = $2`
                _, err := s.db.Exec(ctx, query, id, ownerID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }, retryOpts()...)
}

func retryOpts() []retry.Option <span class="cov8" title="1">{
        return []retry.Option{
                retry.RetryIf(func(err error) bool </span><span class="cov8" title="1">{
                        return pgerrcode.IsConnectionException(pgErrCode(err)) || errors.Is(err, syscall.ECONNREFUSED)
                }</span>),
                retry.DelayType(func(n uint, err error, config *retry.Config) time.Duration <span class="cov0" title="0">{
                        delay := retryDelays[n]
                        return delay
                }</span>),
                retry.OnRetry(func(n uint, err error) <span class="cov0" title="0">{
                        sl.Log.Info(fmt.Sprintf("Failed to connect to database, retrying in %s", retryDelays[n]))
                }</span>),
                retry.Attempts(4),
                retry.LastErrorOnly(true),
        }
}

func pgErrCode(err error) string <span class="cov8" title="1">{
        if e, ok := err.(*pgconn.PgError); ok </span><span class="cov8" title="1">{
                return e.Code
        }</span>

        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package db consists the database utils
package db

import "fmt"

// PostgresDSN creates the postgres database dsn
func PostgresDSN(host string, port int, user string, password string, dbname string) string <span class="cov8" title="1">{
        return fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=disable", user, password, host, port, dbname)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package grpcmd

import (
        "context"
        "errors"
        "strconv"

        "google.golang.org/grpc/metadata"

        "github.com/vindosVP/go-pass/pkg/logger/sl"
)

func ExtractUID(ctx context.Context) (int, error) <span class="cov0" title="0">{

        errFailedToGetUID := errors.New("failed to extract uid from metadata")

        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                sl.Log.Info("no metadata in context")
                return 0, errFailedToGetUID
        }</span>
        <span class="cov0" title="0">uidMd := md.Get("uid")
        if len(uidMd) != 1 </span><span class="cov0" title="0">{
                sl.Log.Info("no uid in metadata")
                return 0, errFailedToGetUID
        }</span>
        <span class="cov0" title="0">uid, err := strconv.Atoi(uidMd[0])
        if err != nil </span><span class="cov0" title="0">{
                sl.Log.Error("failed to convert uid to int", err)
                return 0, errFailedToGetUID
        }</span>
        <span class="cov0" title="0">return uid, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package slogdiscard

import (
        "context"
        "log/slog"
)

type DiscardHandler struct{}

func NewDiscardHandler() *DiscardHandler <span class="cov8" title="1">{
        return &amp;DiscardHandler{}
}</span>

func (h *DiscardHandler) Handle(_ context.Context, _ slog.Record) error <span class="cov0" title="0">{
        return nil
}</span>

func (h *DiscardHandler) WithAttrs(_ []slog.Attr) slog.Handler <span class="cov8" title="1">{
        return h
}</span>

func (h *DiscardHandler) WithGroup(_ string) slog.Handler <span class="cov0" title="0">{
        return h
}</span>

func (h *DiscardHandler) Enabled(_ context.Context, _ slog.Level) bool <span class="cov8" title="1">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package slogpretty initializes and configures pretty logger
package slogpretty

import (
        "context"
        "encoding/json"
        "io"
        stdLog "log"
        "log/slog"

        "github.com/fatih/color"
)

// PrettyHandlerOptions consists logger options
type PrettyHandlerOptions struct {
        SlogOpts *slog.HandlerOptions
}

// PrettyHandler consists the handler fields
type PrettyHandler struct {
        opts PrettyHandlerOptions
        slog.Handler
        l     *stdLog.Logger
        attrs []slog.Attr
}

// NewPrettyHandler creates the pretty handler
func (opts PrettyHandlerOptions) NewPrettyHandler(
        out io.Writer,
) *PrettyHandler <span class="cov0" title="0">{
        h := &amp;PrettyHandler{
                Handler: slog.NewJSONHandler(out, opts.SlogOpts),
                l:       stdLog.New(out, "", 0),
        }

        return h
}</span>

// Handle creates the logger record
func (h *PrettyHandler) Handle(_ context.Context, r slog.Record) error <span class="cov0" title="0">{
        level := r.Level.String() + ":"

        switch r.Level </span>{
        case slog.LevelDebug:<span class="cov0" title="0">
                level = color.MagentaString(level)</span>
        case slog.LevelInfo:<span class="cov0" title="0">
                level = color.BlueString(level)</span>
        case slog.LevelWarn:<span class="cov0" title="0">
                level = color.YellowString(level)</span>
        case slog.LevelError:<span class="cov0" title="0">
                level = color.RedString(level)</span>
        }

        <span class="cov0" title="0">fields := make(map[string]interface{}, r.NumAttrs())

        r.Attrs(func(a slog.Attr) bool </span><span class="cov0" title="0">{
                fields[a.Key] = a.Value.Any()

                return true
        }</span>)

        <span class="cov0" title="0">for _, a := range h.attrs </span><span class="cov0" title="0">{
                fields[a.Key] = a.Value.Any()
        }</span>

        <span class="cov0" title="0">var b []byte
        var err error

        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                b, err = json.MarshalIndent(fields, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">timeStr := r.Time.Format("[15:05:05.000]")
        msg := color.CyanString(r.Message)

        h.l.Println(
                timeStr,
                level,
                msg,
                color.WhiteString(string(b)),
        )

        return nil</span>
}

// WithAttrs creates handler with attributes
func (h *PrettyHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return &amp;PrettyHandler{
                Handler: h.Handler,
                l:       h.l,
                attrs:   attrs,
        }
}</span>

// WithGroup creates handler with group
func (h *PrettyHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;PrettyHandler{
                Handler: h.Handler.WithGroup(name),
                l:       h.l,
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package sl initializes and configures slog logger
package sl

import (
        "log/slog"
        "os"

        "github.com/vindosVP/go-pass/pkg/logger/handlers/slogdiscard"
        "github.com/vindosVP/go-pass/pkg/logger/handlers/slogpretty"
)

const (
        // envLocal is a local environment
        envLocal = "local"

        // envLocal is a development environment
        envDev = "dev"

        // envLocal is a production environment
        envProd = "prod"

        // envTest is a test environment
        envTest = "test"
)

// Log consists configured logger instance
var Log *slog.Logger

// SetupLogger configures the logger depending on environment
func SetupLogger(env string) <span class="cov8" title="1">{
        var log *slog.Logger
        switch env </span>{
        case envLocal:<span class="cov0" title="0">
                opts := slogpretty.PrettyHandlerOptions{
                        SlogOpts: &amp;slog.HandlerOptions{
                                Level: slog.LevelDebug,
                        },
                }

                handler := opts.NewPrettyHandler(os.Stdout)

                log = slog.New(handler)</span>
        case envDev:<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelDebug}),
                )</span>
        case envProd:<span class="cov0" title="0">
                log = slog.New(
                        slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelInfo}),
                )</span>
        case envTest:<span class="cov8" title="1">
                log = slog.New(
                        slogdiscard.NewDiscardHandler(),
                )</span>
        }
        <span class="cov8" title="1">Log = log</span>
}

func Err(err error) slog.Attr <span class="cov8" title="1">{
        return slog.Attr{
                Key:   "error",
                Value: slog.StringValue(err.Error()),
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
